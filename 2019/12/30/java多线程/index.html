<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","width":400,"display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="基础api先看下线程相关的基础继承Thread 和实现Runnable的区别基础Thread后.就没法继承其他类了.局限性大.实现runnable后还可以集成别的类.线程由线程调度器来调度.执行start的方法的顺序不代表线程的启动顺序">
<meta property="og:type" content="article">
<meta property="og:title" content="java多线程">
<meta property="og:url" content="http://yoursite.com/2019/12/30/java多线程/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础api先看下线程相关的基础继承Thread 和实现Runnable的区别基础Thread后.就没法继承其他类了.局限性大.实现runnable后还可以集成别的类.线程由线程调度器来调度.执行start的方法的顺序不代表线程的启动顺序">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2019/12/30/java多线程/006tNbRwly1gagytd457oj30aj06y754.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/30/java多线程/006tNbRwly1gagyxa7fcrj30dp09edgs.jpg">
<meta property="og:image" content="http://yoursite.com/2019/12/30/java多线程/image-20200101125936202.png">
<meta property="og:image" content="http://yoursite.com/2019/12/30/java多线程/image-20200101134334485.png">
<meta property="og:updated_time" content="2020-03-07T11:59:58.593Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java多线程">
<meta name="twitter:description" content="基础api先看下线程相关的基础继承Thread 和实现Runnable的区别基础Thread后.就没法继承其他类了.局限性大.实现runnable后还可以集成别的类.线程由线程调度器来调度.执行start的方法的顺序不代表线程的启动顺序">
<meta name="twitter:image" content="http://yoursite.com/2019/12/30/java多线程/006tNbRwly1gagytd457oj30aj06y754.jpg">
  <link rel="canonical" href="http://yoursite.com/2019/12/30/java多线程/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>java多线程 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/30/java多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujiakuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">java多线程

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-30 21:17:24" itemprop="dateCreated datePublished" datetime="2019-12-30T21:17:24+08:00">2019-12-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-07 19:59:58" itemprop="dateModified" datetime="2020-03-07T19:59:58+08:00">2020-03-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基础api"><a href="#基础api" class="headerlink" title="基础api"></a>基础api</h1><p>先看下线程相关的基础</p><h2 id="继承Thread-和实现Runnable的区别"><a href="#继承Thread-和实现Runnable的区别" class="headerlink" title="继承Thread 和实现Runnable的区别"></a>继承Thread 和实现Runnable的区别</h2><p>基础Thread后.就没法继承其他类了.局限性大.实现runnable后还可以集成别的类.</p><p>线程由线程调度器来调度.执行start的方法的顺序不代表线程的启动顺序</p><a id="more"></a>


<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol>
<li><p>使用退出标志,在run方法完成后退出</p>
</li>
<li><p>使用stop中止,但是不推荐,stop是过期作废方法,如果对象有锁,stop会释放锁.但是会造成数据不一致.</p>
</li>
<li><p>使用interrupt中断线程 </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">中断方式1</span><br><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">      try &#123;</span><br><span class="line">        for (int i = 0; i &lt; 500000; i++) &#123;</span><br><span class="line">            if(this.isInterrupted())&#123;</span><br><span class="line">                System.out.println(&quot;中断了&quot;);</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count.incrementAndGet()+&quot;--&quot;+ this.isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">         System.out.println(&quot;线程内部中止&quot;);</span><br><span class="line">     &#125;&#125;</span><br><span class="line"> 中断方式2</span><br><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">   </span><br><span class="line">        for (int i = 0; i &lt; 500000; i++) &#123;</span><br><span class="line">            if(this.isInterrupted())&#123;</span><br><span class="line">                System.out.println(&quot;中断了&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(count.incrementAndGet()+&quot;--&quot;+ this.isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="interrupted-和-isInterrupted"><a href="#interrupted-和-isInterrupted" class="headerlink" title="interrupted()和 isInterrupted()"></a>interrupted()和 isInterrupted()</h2><p>static boolean interrupted() 静态方法,看调用他的这个线程是否已经中断,调用时会清除调中断状态.(也就是连续两次调用,如果第一次返回true,第二次就返回false.因为返回true时已将中断状态给清除了)</p>
<p>void isInterrupted()属性方法,属于某个线程,是测试具有这个方法的线程是否中断,不会清除中断状态.</p>
<h2 id="suspend-和-resume"><a href="#suspend-和-resume" class="headerlink" title="suspend 和 resume"></a>suspend 和 resume</h2><p>用来暂停线程和恢复线程, 但是他们不释放锁. 同时.在恢复后可能会导致数据不同步.</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>会使当前线程让出CPU资源但是让出的时间不确定.可能是刚让出,又马上获得CPU</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>优先级具有继承性, A启动B线程,AB的优先级就是一样的.java分为10个优先级, 高优先级大部分情况先执行完,但不保证     this.<strong>setPriority</strong>(newPriority);</p>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>当进程中不存在非守护进程时,守护进程自动销毁 .垃圾回收线程就是守护线程</p>
<p>thread.setDeamon(true)</p>
<h1 id="并发访问"><a href="#并发访问" class="headerlink" title="并发访问"></a>并发访问</h1><h2 id="Synchronized-同步方法"><a href="#Synchronized-同步方法" class="headerlink" title="Synchronized 同步方法"></a>Synchronized 同步方法</h2><p>线程拥有自己的程序计数器,寄存器,和一个堆栈.而局部变量是在栈上.所以线程的方法内的局部变量.是不存在并发访问问题的.</p>
<p>并发访问问题主要是多个线程访问相同的实例变量.由于线程的执行时的切换.导致数据错乱.</p>
<p>Synchronized是用来进行同步的关键字.可以给对象加锁.对一个对象加锁后.同一时间只允许一个线程访问这个对象.</p>
<p>注意.Synchronized给对象加锁.而同一个类的不同对象是不同的锁.</p>
<h3 id="锁的可重入性"><a href="#锁的可重入性" class="headerlink" title="锁的可重入性:"></a>锁的可重入性:</h3><p> 同一时间.一个线程a获得了对象b的锁,如果b有三个加锁的方法,这三个方法此时都只能由a进入,其他线程需要等a释放锁后才能进入b的加锁方法. 也就是一旦给某个对象加锁.就锁住了他的全部同步方法.</p>
<p>一个对象的锁只能同时被一个线程拿到.无论锁是方法锁还是代码块锁.</p>
<p>静态方法加锁.锁的是这个静态方法所在的类的class对象. class锁可以锁住改类的全部对象.</p>
<p>对于字符串来说.同样的值是同一个对象.是同一个锁,因此不能使用string做锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setValue,getBigValue,setBigValue在同一时间只能被一个线程访问.其他所有线程都需要等待该线程释放锁</span><br><span class="line">public class DirtyOBj&#123;</span><br><span class="line">    int val=0;</span><br><span class="line">    synchronized public void setValue(int val)&#123;</span><br><span class="line">        this.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    synchronized public int getBigValue()&#123;</span><br><span class="line">        return  this.val+10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public int setBigValue(int val ,int valB)&#123;</span><br><span class="line">        return  this.val+valB;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getValue()&#123;</span><br><span class="line">        return this.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类集成父类的锁方法时,也是可重入的.也就是可以调用父类的锁方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    synchronized public int getVal()&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">   synchronized public int setVal()&#123; //获取了这个锁.也可以访问父类的同步的锁方法.</span><br><span class="line">       int i = getVal();</span><br><span class="line">        return  i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读:"></a>脏读:</h3><p>在读取变量时,数据被其他线程改动了.如下,虽然写的方法加锁了.但是读没有加锁.就可能在同步写的时候,导致异步读,会产生脏数据. 因此对共享对象的读写都要同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DirtyOBj&#123;</span><br><span class="line">    int val=0; </span><br><span class="line">    synchronized public void setValue(int val)&#123;</span><br><span class="line">        this.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getValue()&#123;</span><br><span class="line">        return this.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>volatile 作用是使变量在多个线程间可见. 因为线程有自己的缓冲空间.有时会使数据不同步.使用volatile会使线程强制从内存中读取数据.保证数据一致性. </p>
<p>但是volatile 不保证数据操作的原子性.因此是只保证读是最新的,不保证写的完整执行.</p>
<p><img src="/2019/12/30/java多线程/006tNbRwly1gagytd457oj30aj06y754.jpg" alt="image-20200101124931159"></p>
<p>使用volatile后</p>
<p><img src="/2019/12/30/java多线程/006tNbRwly1gagyxa7fcrj30dp09edgs.jpg" alt="image-20200101125319271"></p>
<p>volatile 只能修饰变量.并且不会加锁.但是不保证数据的原子性.(就是写操作比如 i++,并不保证三个步骤一起执行完成)</p>
<p>volatile 只解决变量在多个线程之间的可见性.</p>
<p>synchronize 保证原子性和可见性,会阻塞多线程访问,保证访问顺序,会同步工作内存和主内存的数据,</p>
<p>原子操作是指不可分割的整体,没有线程可以中断正在原子操作的变量.</p>
<p><img src="/2019/12/30/java多线程/image-20200101125936202.png" alt="image-20200101125936202"></p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><h2 id="线程状态切换"><a href="#线程状态切换" class="headerlink" title="线程状态切换"></a>线程状态切换</h2><p><img src="/2019/12/30/java多线程/image-20200101134334485.png" alt="image-20200101134334485"></p>
<p>其实就是 运行和就绪状态的切换.由系统调度器觉得. 而线程被阻塞后(无论是否有锁.都进入暂停状态.)需要外界达到某些条件才能转为就绪状态.</p>
<h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>wait 方法.来自Object.表示等待某些条件.必须在获取到某个锁之后才能调用.且 wait方法会释放锁(因此必须持有锁).wait方法后.该线程从运行状态退出.进入阻塞队列.</p>
<p>wait后.如果调用线程的interrupt方法.会抛出异常.  </p>
<p>wait 的线程被唤醒后.会与其他线程竞争获取锁.</p>
<p>每个锁对象都有两个队列.就绪队列和阻塞队列.就绪队列就是获取锁的线程,等待调度器调度执行.阻塞队列是没有拿到锁的线程.</p>
<p>notify方式唤醒wait 等待的方法.notify的线程必须要获取到该锁.才能唤醒.执行notify后.也不是立刻就释放锁.而是notify的线程执行完同步方法后.退出同步方法.在释放锁.然后wait的线程拿到锁.</p>
<p>sleep 方法不会释放锁.但是可能会被中断.因此要trycatch 处理异常.出现异常会导致锁被释放.</p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题."></a>生产者消费者问题.</h2><p>多个生产者-消费者,需要互相唤醒.还有就是对资源数量的判断.还要防止其他线程对资源数量的该表造成错误.还需要在达到条件时,唤醒对方.</p>
<p>需要注意几点, 通过notifyall.来唤醒对方.防止只唤醒了另一个同类</p>
<p>对数据的判断使用while 而不是if.</p>
<p>对数据处理的方法都要加锁.(get和set) </p>
<p>这两个方法.因为是对同一个资源修改.因此要给同样的对象加锁.</p>
<p>生产者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setValue() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123; //主要方法加锁 </span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                while (!ValueObject.get) &#123; //判断是否满足生产条件</span><br><span class="line">                //使用while.因为下边要wait.如果使用if.在唤醒后数据资源发送变化.会导致错误.            </span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;provider &quot; + Thread.currentThread().getName() + &quot; </span><br><span class="line">                ValueObject.value = value;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void getValue() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           synchronized (lock) &#123;//主要方法加锁 </span><br><span class="line">               Thread.sleep(100);</span><br><span class="line">               while (&quot;&quot;.equals(ValueObject.value)) &#123;//判断是否满足消费条件,不满足就等待</span><br><span class="line">               //使用while.因为下边要wait.如果使用if.在唤醒后数据资源发送变化.会导致错误.</span><br><span class="line"></span><br><span class="line">                   lock.wait();</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               ValueObject.value = &quot;&quot;;</span><br><span class="line">               lock.notifyAll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>管道流用来在不同线程间传递数据,一个线程输出数据到管道.另一个线程从管道中读取数据</p>
<p>管道是单向的.只能从一方流到另一方</p>
<p>PipedInputStream 和 PipedOutputStream</p>
<p>PipedReader和PipedWriter</p>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void readMethod(PipedInputStream in) &#123;//在一个线程中执行</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;read : &quot;);</span><br><span class="line">            byte[] bytes = new byte[20];</span><br><span class="line">            int length = in.read(bytes); //读数据会阻塞住.如果流里没有数据的话</span><br><span class="line">            while (length != -1) &#123;</span><br><span class="line">                String newData = new String(bytes, 0, length);</span><br><span class="line">                System.out.print(newData);</span><br><span class="line">                length = in.read(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;read : finish&quot;);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void writeMethod(PipedOutputStream out) &#123; //在一个线程中执行</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;write : &quot;);</span><br><span class="line">            for (int i = 0; i &lt; 30; i++) &#123;</span><br><span class="line">                String outData = &quot;&quot; + (i + 1);</span><br><span class="line">                out.write(outData.getBytes());</span><br><span class="line">                System.out.print(outData);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;write : finish&quot;);</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="流的连接"><a href="#流的连接" class="headerlink" title="流的连接"></a>流的连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream in = new PipedInputStream();</span><br><span class="line">   PipedOutputStream out = new PipedOutputStream();</span><br><span class="line">    </span><br><span class="line">   //使用connect的作用是 使两个Stream之间产生同行链接，这样才可以将数据进行输出输入。</span><br><span class="line">   in.connect(out);</span><br><span class="line">   // out.connect(in);</span><br></pre></td></tr></table></figure>

<h2 id="join-等待线程销毁"><a href="#join-等待线程销毁" class="headerlink" title="join (等待线程销毁)"></a>join (等待线程销毁)</h2><p>join是线程的方法,线程A中调用线程B的join方法,表示A要阻塞直到线程B执行完run方法在唤醒A.</p>
<p>join内部是使用wait实现,因此join具有释放锁的效果.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyThread thread = new MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">            thread.join();   //main方法的线程等待Thread线程执行结束后在继续执行之后代码</span><br><span class="line">            System.out.println(&quot;End timer = &quot; + System.currentTimeMillis());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock-类"><a href="#ReentrantLock-类" class="headerlink" title="ReentrantLock 类"></a>ReentrantLock 类</h2><p>ReentrantLock 可以支持产生多个锁条件.在每个锁条件上都阻塞线程.可以单独对特地的锁条件进行唤醒.我认为这个锁的概念比较接近 管程的概念 .</p>
<p>ReentrantLock产生的Condition都具有signalAll和await.同一个condition的两个方法搭配.不同的condition的signalAll和await不影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MyService &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    private Condition conditionB = lock.newCondition();</span><br><span class="line">    private Condition conditionA = lock.newCondition();</span><br><span class="line">    private boolean hasValue = false;</span><br><span class="line">    set 和 get方法分别由不同的线程执行,没个方法都进行了lock和unlock,保证只能同时有一个线程进入.</span><br><span class="line">    不满足条件时,会分别等在各自条件的await出.等待对方满足条件后进行唤醒</span><br><span class="line">    public void set() &#123; </span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (hasValue) &#123;</span><br><span class="line">                System.out.println(&quot;有可能★★连续&quot;);</span><br><span class="line">                conditionA.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;打印★&quot;);</span><br><span class="line">            hasValue = true;</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void get() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (!hasValue) &#123;</span><br><span class="line">                System.out.println(&quot;有可能☆☆连续&quot;);</span><br><span class="line">                conditionB.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;打印☆&quot;);</span><br><span class="line">            hasValue = false;</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="延迟加载-懒汉模式"><a href="#延迟加载-懒汉模式" class="headerlink" title="延迟加载.懒汉模式"></a>延迟加载.懒汉模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyObjec &#123;</span><br><span class="line">    private volatile static MyObjec obj;  volatile关键字防止指令乱序执行.</span><br><span class="line">    private  MyObjec()&#123;&#125;;</span><br><span class="line">     //静态方式加锁.效率低</span><br><span class="line">      public static MyObjec getInstance()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if(obj != null)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                Thread.sleep(3000);//模拟初始化</span><br><span class="line">                synchronized (MyObjec.class)&#123;//这里同步执行.会导致线程阻塞</span><br><span class="line">                    if(obj ==null)&#123; </span><br><span class="line">               //这里的判断是为了.如果第一个线程已经创建obj,离开同步块后第二个进程还是判空.又初始化一遍.</span><br><span class="line">                        obj=new MyObjec();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类模式"><a href="#静态内部类模式" class="headerlink" title="静态内部类模式"></a>静态内部类模式</h2><p>静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存。即当SingleTon第一次被加载时，并不需要去加载SingleTonHoler，只有当getInstance()方法第一次被调用时，才会去初始化INSTANCE,第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。<br>而对类的初始化是由虚拟机来保证多线程环境中唯一性的.因此就保证了SingltTon的唯一性.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private  SingleTon()&#123;&#125;;</span><br><span class="line">    private static class MyObjectHandler&#123;</span><br><span class="line">        private static SingleTon obj= new SingleTon();</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance()&#123;</span><br><span class="line">        return MyObjectHandler.obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态代码块模式"><a href="#静态代码块模式" class="headerlink" title="静态代码块模式"></a>静态代码块模式</h2><p>静态代码块在加载类的时候就会执行.也可以保证唯一性.类似静态内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">   private static SingleTon INSTANCE null;</span><br><span class="line">   static &#123;INSTANCE=new SingleTon(); &#125;</span><br><span class="line">	 private SingleTon()&#123;&#125;</span><br><span class="line">	public static SingleTon getInstance()&#123; return INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="恶汉模式"><a href="#恶汉模式" class="headerlink" title="恶汉模式"></a>恶汉模式</h2><p>饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon&#123;</span><br><span class="line">   private static SingleTon INSTANCE = new SingleTon();</span><br><span class="line">	 private SingleTon()&#123;&#125;</span><br><span class="line">	public static SingleTon getInstance()&#123; return INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/12/10/深入理解计算机系统图床版/" rel="next" title="深入理解计算机系统图床版">
                  <i class="fa fa-chevron-left"></i> 深入理解计算机系统图床版
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/01/23/深入理解java虚拟机的-图床版/" rel="prev" title="深入理解java虚拟机-图传版">
                  深入理解java虚拟机-图传版 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liujiakuo</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础api"><span class="nav-text">基础api</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#继承Thread-和实现Runnable的区别"><span class="nav-text">继承Thread 和实现Runnable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止线程"><span class="nav-text">停止线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupted-和-isInterrupted"><span class="nav-text">interrupted()和 isInterrupted()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#suspend-和-resume"><span class="nav-text">suspend 和 resume</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield"><span class="nav-text">yield</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护进程"><span class="nav-text">守护进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发访问"><span class="nav-text">并发访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized-同步方法"><span class="nav-text">Synchronized 同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的可重入性"><span class="nav-text">锁的可重入性:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#脏读"><span class="nav-text">脏读:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-关键字"><span class="nav-text">volatile 关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程间通信"><span class="nav-text">线程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态切换"><span class="nav-text">线程状态切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待-通知机制"><span class="nav-text">等待/通知机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者问题"><span class="nav-text">生产者消费者问题.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节流"><span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读数据"><span class="nav-text">读数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写数据"><span class="nav-text">写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的连接"><span class="nav-text">流的连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join-等待线程销毁"><span class="nav-text">join (等待线程销毁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-类"><span class="nav-text">ReentrantLock 类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例模式"><span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟加载-懒汉模式"><span class="nav-text">延迟加载.懒汉模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态内部类模式"><span class="nav-text">静态内部类模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态代码块模式"><span class="nav-text">静态代码块模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#恶汉模式"><span class="nav-text">恶汉模式</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujiakuo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
