<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","width":400,"display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="WMSWMS主要负责两个功能, 一是负责窗口的管理,如窗口的增加删除,层级.二是负责全局事件的派发.如触摸点击事件.先简单介绍几个重要的类IWindowSession.  进程唯一的.是一个匿名binder.通过他向WMS请求窗口操作">
<meta property="og:type" content="website">
<meta property="og:title" content="深入理解android2-WMS,控件-图床版">
<meta property="og:url" content="http://yoursite.com/图床/深入理解android2-WMS-图床版.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="WMSWMS主要负责两个功能, 一是负责窗口的管理,如窗口的增加删除,层级.二是负责全局事件的派发.如触摸点击事件.先简单介绍几个重要的类IWindowSession.  进程唯一的.是一个匿名binder.通过他向WMS请求窗口操作">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr623frjtj30t10c4taa.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr6289yc6j30rm083t9m.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr62behcvj30oy0i3diq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr623ylwcj30he0dumxf.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr62958c8j30se0j5gq1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr62ai2erj30l409baas.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr629yupej30m80en75k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr625ev1uj30f808taai.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr62bwk5uj30r70l1mzp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr62azldjj30eh088aaw.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr626tj15j30fh06jglz.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr624gp93j30fz0brgmp.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr626c0ctj315g0jq77j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr6230nzzj30l80o2wgg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr624xpu5j30ll09jdgu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr627nhagj30ou0oetaq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr625vo6dj309e0463yl.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr6277nh0j30fs07h0t1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr628nfrtj319u0t6422.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr629mwh0j31920u0dq2.jpg">
<meta property="og:updated_time" content="2020-03-12T07:17:01.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解android2-WMS,控件-图床版">
<meta name="twitter:description" content="WMSWMS主要负责两个功能, 一是负责窗口的管理,如窗口的增加删除,层级.二是负责全局事件的派发.如触摸点击事件.先简单介绍几个重要的类IWindowSession.  进程唯一的.是一个匿名binder.通过他向WMS请求窗口操作">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gcr623frjtj30t10c4taa.jpg">
  <link rel="canonical" href="http://yoursite.com/图床/深入理解android2-WMS-图床版">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title>深入理解android2-WMS,控件-图床版 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

    
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">深入理解android2-WMS,控件-图床版

</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
        
          <h1 id="WMS"><a href="#WMS" class="headerlink" title="WMS"></a>WMS</h1><p>WMS主要负责两个功能, 一是负责窗口的管理,如窗口的增加删除,层级.二是负责全局事件的派发.如触摸点击事件.</p><p>先简单介绍几个重要的类</p><p>IWindowSession.  进程唯一的.是一个匿名binder.通过他向WMS请求窗口操作</p><a id="more"></a>


<p>surface 绘画时,canvas会把内容绘制到surface里.surface是有surfaceFlinger提供给客户端的.</p>
<p>WindowManager.LayoutParams 集成自ViewGroup.LayoutParams.用来指明client端的窗口的一些属性.最重要的是type. 根据这属性来对多个窗口进程ZOrder的排序.</p>
<p>windowToken.向WMS添加的窗口令牌.每个窗口都要有一个令牌.</p>
<p>IWindow. 是client提供给WMS的.继承自binder.WMS通过IWindow对象来主动发起client端的事件.</p>
<p>窗口的本周就是进行绘制所使用的surface,客户端向WMS添加窗口的过程,就是WMS为客户端分配surface的过程.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr623frjtj30t10c4taa.jpg" alt="image-20200308202908157"></p>
<p>ui框架层就是使用surface上绘制ui元素.及响应输入事件</p>
<p>WMS负责surface的分配.窗口的层级顺序</p>
<p>surfaceFlinger负责将多个Surface混合并输出.</p>
<h2 id="WMS-启动"><a href="#WMS-启动" class="headerlink" title="WMS 启动"></a>WMS 启动</h2><p>WMS有SystemServer 进程启动.他和AMS其实是运行于一个进程中的.只是分别有各自的线程.</p>
<h3 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h3><ol>
<li>显示创建两个HandlerThread.和对应的handler.一个叫ui,一个叫windowManager.这两个HandlerThread就会在run中循环接受发过来的消息.</li>
<li>调用WMS的main.传入两个handler.返回一个WMS对象,加入ServiceManager管理</li>
<li>初始化显示信息,主要是显示持续相关.完成后WMS会要求AMS进行配置更新</li>
<li>通知WMS初始化完成,调用windowManagerPolicy的systemReady</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//创建两个 HandlerThread</span><br><span class="line">HandlerThread uiHandlerThread = new HandlerThread(&quot;UI&quot;);</span><br><span class="line"> uiHandlerThread.start();</span><br><span class="line"> Handler uiHandler = new Handler(uiHandlerThread.getLooper());</span><br><span class="line">    </span><br><span class="line">HandlerThread wmHandlerThread = new HandlerThread(&quot;WindowManager&quot;);</span><br><span class="line"> wmHandlerThread.start();</span><br><span class="line"> Handler wmHandler = new Handler(wmHandlerThread.getLooper());</span><br><span class="line"> //调用WMS.main 返回一个WMS对象,加入ServiceManager管理</span><br><span class="line"> wm = WindowManagerService.main(context, power, display, inputManager,</span><br><span class="line">               uiHandler, wmHandler,</span><br><span class="line">               factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">               !firstBoot, onlyCore);</span><br><span class="line">  ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">  //初始化显示信息     </span><br><span class="line">  wm.displayReady();</span><br><span class="line">  //通知WMS初始化完成.  </span><br><span class="line">  wm.systemReady();</span><br></pre></td></tr></table></figure>

<h3 id="WMS-main"><a href="#WMS-main" class="headerlink" title="WMS.main"></a>WMS.main</h3><p>上边传入了两个handler.这里就使用windowManager的handler来创建WMS.也就是在一个handerThread线程中创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   public static WindowManagerService main(final Context context,</span><br><span class="line">            final PowerManagerService pm, final DisplayManagerService dm,</span><br><span class="line">            final InputManagerService im,</span><br><span class="line">            final Handler uiHandler, final Handler wmHandler,</span><br><span class="line">            final boolean haveInputMethods, final boolean showBootMsgs,</span><br><span class="line">            final boolean onlyCore) &#123;</span><br><span class="line">        final WindowManagerService[] holder = new WindowManagerService[1];</span><br><span class="line">        //在名为WindowManager的handlerThread创建WMS,注意,传入WMS了uiHandler.这是另一个handlerThread</span><br><span class="line">        wmHandler.runWithScissors(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                holder[0] = new WindowManagerService(context, pm, dm, im,</span><br><span class="line">                        uiHandler, haveInputMethods, showBootMsgs, onlyCore);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        return holder[0];</span><br><span class="line">    &#125;</span><br><span class="line"> WMS构造函数主要有下</span><br><span class="line">1. 初始化了很多东西.包括动画相关屏幕相关</span><br><span class="line">2. 保存输入事件的服务, WMS要管理输入事件</span><br><span class="line">mInputManager = inputManager;</span><br><span class="line">3. 对ui线程进行初始.这里创建的WindowManagerPolicy</span><br><span class="line">initPolicy(uiHandler);</span><br></pre></td></tr></table></figure>

<h3 id="WMS的重要成员"><a href="#WMS的重要成员" class="headerlink" title="WMS的重要成员"></a>WMS的重要成员</h3><h4 id="InputManagerService-mInputManager"><a href="#InputManagerService-mInputManager" class="headerlink" title="InputManagerService mInputManager"></a>InputManagerService mInputManager</h4><p>用来管理每个窗口的事件输入.也就是把输入事件转发到正确的窗口</p>
<h4 id="Choreographer-mChoreographer"><a href="#Choreographer-mChoreographer" class="headerlink" title="Choreographer mChoreographer"></a>Choreographer mChoreographer</h4><p>能获取显示系统的同步信号.用来驱动动画的渲染</p>
<h4 id="WindowAnimator-mAnimator"><a href="#WindowAnimator-mAnimator" class="headerlink" title="WindowAnimator mAnimator"></a>WindowAnimator mAnimator</h4><p>所有窗口动画的总管,在mChoreographer的驱动下渲染所有动画</p>
<h4 id="WindowManagerPolicy-mPolicy"><a href="#WindowManagerPolicy-mPolicy" class="headerlink" title="WindowManagerPolicy mPolicy"></a>WindowManagerPolicy mPolicy</h4><p>只有PhoneWindowManager一个实现.定义了很多窗口相关的策略.是最重要的成员,比如负责窗口的zorder顺序.</p>
<p>zorder就是各个窗口在z轴的值.越大越在屏幕上层.窗口就是根据zorder值一层一层堆在一起.</p>
<h4 id="SparseArray-mDisplayContents"><a href="#SparseArray-mDisplayContents" class="headerlink" title="SparseArray mDisplayContents"></a>SparseArray mDisplayContents</h4><p>可以绘制的屏幕列表.默认是只有1个.</p>
<h4 id="HashMap-lt-IApplicationToken-WindowToken-gt-mTokenMap"><a href="#HashMap-lt-IApplicationToken-WindowToken-gt-mTokenMap" class="headerlink" title="HashMap&lt;IApplicationToken, WindowToken&gt; mTokenMap"></a>HashMap&lt;IApplicationToken, WindowToken&gt; mTokenMap</h4><p>管理所以窗口的显示令牌token,每个窗口都要属于一个token.这里的IBinder 是</p>
<h4 id="ArrayList-lt-AppWindowToken-gt-mAppTokens"><a href="#ArrayList-lt-AppWindowToken-gt-mAppTokens" class="headerlink" title="ArrayList&lt; AppWindowToken&gt; mAppTokens"></a>ArrayList&lt; AppWindowToken&gt; mAppTokens</h4><p>表示所有Activity的token. AppWindowToken是WindowToken的子类,这个list的顺序和AMS中对mHistory列表中activity的顺序是一样的 .反应了系统中activity的叠加顺序.也就是说.所有窗口都有WindowToken.而Activity对应的窗口则多了AppWindowToken.</p>
<h4 id="HashMap-lt-IWIndow-WindowState-gt-mWindowMap"><a href="#HashMap-lt-IWIndow-WindowState-gt-mWindowMap" class="headerlink" title="HashMap&lt;IWIndow, WindowState&gt; mWindowMap"></a>HashMap&lt;IWIndow, WindowState&gt; mWindowMap</h4><p>每个窗口都对应一个WindowState.存储改窗口的状态信息(这就和AMS中对每个activity抽象成ActivityRecord一样)</p>
<p>这里的iBinder 是IWIndow类.</p>
<h4 id="HashSet-lt-Session-gt-mSessions"><a href="#HashSet-lt-Session-gt-mSessions" class="headerlink" title="HashSet&lt; Session &gt;  mSessions"></a>HashSet&lt; Session &gt;  mSessions</h4><p>Session 是WMS提供给客户端来与WMS进行交互的,这是匿名binder.为了减轻WMS的负担.客户端通过IWindowManager.openSession 拿到他的代理.然后通过代理与WMS交互.每个进程唯一.</p>
<h2 id="WMS窗口管理结构"><a href="#WMS窗口管理结构" class="headerlink" title="WMS窗口管理结构"></a>WMS窗口管理结构</h2><h3 id="添加窗口"><a href="#添加窗口" class="headerlink" title="添加窗口"></a>添加窗口</h3><p>客户端通过IWindowSession.add 来添加窗口. iWindowSession 是同aidl形成的.最终到了WMS.addWindow.</p>
<ol>
<li><p>获取要显示的屏幕</p>
</li>
<li><p>找到了这个窗口对应的windowToken,可以为空,为空就新建一个并保存.然后是对窗口类型的各种判断.</p>
</li>
<li><p>为APP的窗口创建WindowState对象.维护窗口的所有信息.</p>
</li>
<li><p>WindowManagerPolicy出现,调整了layoutparams的参数.</p>
</li>
<li><p>保存这个新窗口的token令牌和生成的WindowState.并调用WindowState的attach</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public int addWindow(Session session, IWindow client, int seq,</span><br><span class="line">            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,</span><br><span class="line">            Rect outContentInsets, InputChannel outInputChannel) &#123;</span><br><span class="line">  1.获取要显示的屏幕          </span><br><span class="line">  final DisplayContent displayContent = getDisplayContentLocked(displayId);            </span><br><span class="line">   //attrs 是   LayoutParams, attrs.type表示窗口的类型.attrs.toekn表示窗口属于哪个对象.</span><br><span class="line">   //2.这里找到了这个窗口对应的windowToken</span><br><span class="line">   WindowToken token = mTokenMap.get(attrs.token); </span><br><span class="line">    if (token == null) &#123;</span><br><span class="line">        token = new WindowToken(this, attrs.token, -1, false);</span><br><span class="line">    &#125;elseif (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        AppWindowToken atoken = token.appWindowToken;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.为APP的窗口创建WindowState</span><br><span class="line">    win = new WindowState(this, session, client, token,</span><br><span class="line">                    attachedWindow, seq, attrs, viewVisibility, displayContent);</span><br><span class="line">     4.WindowManagerPolicy出现,调整了layoutparams的参数.               </span><br><span class="line">     mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">        win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line"></span><br><span class="line">        res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">	5. 保存这个新窗口的token令牌和生成的WindowState.并调用WindowState的attach</span><br><span class="line">   if (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里总的来说就是确立了客户窗口的WindowToken.WindowState.和DisplayContent. 并都保存了起来.同时根据layoutparams.type进行了些窗口等级的判断.</p>
<h3 id="理解windowToken"><a href="#理解windowToken" class="headerlink" title="理解windowToken"></a>理解windowToken</h3><p>WindowToken将同一个应用组件的窗口安排在一起.一个应用组件可以是Activity,InputMethod.</p>
<p>WindowToken使应用组件在变更窗口时必须与自己的WindowToken匹配.</p>
<p>这里主要是为了处理窗口的层级关系而设立的.</p>
<p>只要是一个binder对象.都可以作为token向wms声明.wms会把这个binder对应起一个WindowToken.其实就是把客户端的binder和wms里的一个WindowToken对象进行了绑定.</p>
<p>因为Activity比较复杂,因此WMS为Activity实现了WindowToken的子类 appwindowtoken.同时在AMS启动Activity的ActivityStack.startActivityLocked里声明token.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  mService.mWindowManager.addAppToken(addPos, r.userId, r.appToken,</span><br><span class="line">          r.task.taskId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">          (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0);  </span><br><span class="line">          </span><br><span class="line">r 是要启动Activity的ActivityRecord  r.apptoken就是这个binder</span><br></pre></td></tr></table></figure>

<p>然后在activityStack.realStartActivityLocked里在发给用户进程,然后用户在通过这个binder和WMS交互时带过来.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                   System.identityHashCode(r), r.info,</span><br><span class="line">                   new Configuration(mService.mConfiguration),</span><br><span class="line">                   r.compat, r.icicle, results, newIntents, !andResume,</span><br><span class="line">                   mService.isNextTransitionForward(), profileFile, profileFd,</span><br><span class="line">                   profileAutoStop);</span><br><span class="line"> r.appToken 就是这个binder</span><br></pre></td></tr></table></figure>

<p>activity则在 activityStack 线程的handleResumeActivity 里把Activity 对应的窗口,加入到wMS中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,</span><br><span class="line">            boolean reallyResume) &#123;</span><br><span class="line">            </span><br><span class="line">ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">ViewManager wm = a.getWindowManager();</span><br><span class="line">      WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">      a.mDecor = decor;</span><br><span class="line">      l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">      l.softInputMode |= forwardBit;</span><br><span class="line">      if (a.mVisibleFromClient) &#123;</span><br><span class="line">          a.mWindowAdded = true;</span><br><span class="line">          wm.addView(decor, l);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取消token 也是在AMS中 ,也就是说, AMS负责avtivity的token向WMS的添加和删除.</p>
<p>当然.Activity的 r.appToken 是 IApplicationToken.Stub ,他里边有一系列的窗口相关的通知回调.</p>
<p>这里总结下. AMS在创建Activity的ActivityRecord时,创建了他的appToken,有把appToken传送给WMS.WMS对应匹配为APPWindowToken,最后还把这个appToken发送给activity.因此AMS就通过ActivityRecord就可有直接操作WMS对该窗口的绘制.如图.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr6289yc6j30rm083t9m.jpg" alt="image-20200308224158968"></p>
<h3 id="理解WindowState"><a href="#理解WindowState" class="headerlink" title="理解WindowState"></a>理解WindowState</h3><p>每个window在WMS里都抽象成了WindowState.他包含一个窗口的所有属性.WindowState在客户端对应的则是iWidow.stub类.iWidow.stub有很多窗口通知的回调.</p>
<p>WindowState被保存在mWindowMap里.这是整个系统所有窗口的一个全集.</p>
<p>HashMap&lt;IBinder, WindowToken&gt; mTokenMap .这里是 IApplicationToken(客户端)和WindowToken的映射</p>
<p>HashMap&lt;IBinder, WindowState&gt; mWindowMap 这里是IWidow(客户端)和WindowState的映射,并且WMS通过这个IWindow 来回调客户端的方法.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr62behcvj30oy0i3diq.jpg" alt="image-20200308225135573"></p>
<p>上图可以看出.每个activity 只有一个ActivityRecord.也只有一个AppToken,也就只有一个WindowToken.而一个acitvity可能有多个窗口.每个窗口对应一个WindowState. </p>
<p>WindowToken用来和AMS交换. 而WindowState对应的iWindow则是WMS来与客户端交互的.</p>
<h3 id="窗口显示次序"><a href="#窗口显示次序" class="headerlink" title="窗口显示次序"></a>窗口显示次序</h3><p>窗口显示次序就是窗口在Z轴的排了.因为窗口是叠加在一起的.因此就需要知道哪些显示在上边,哪些在下边.这个由WindowState构造时确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 窗口类型是子窗口</span><br><span class="line">if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">            mBaseLayer = mPolicy.getWindowLayerLw(parentWindow)</span><br><span class="line">                    * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">            mSubLayer = mPolicy.getSubWindowLayerFromTypeLw(a.type);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">窗口类型是普通窗口</span><br><span class="line">      mBaseLayer = mPolicy.getWindowLayerLw(this)</span><br><span class="line">              * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">      mSubLayer = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可见.分配规则是由WindowManagerPolicy mPolicy来决定的.产生 mBaseLayer和mSubLayer. mBaseLayer决定该窗口和他的子窗口在所有窗口的显示位置. mSubLayer决定子窗口在同级的兄弟窗口的显示位置.值越高.显示约靠上.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr623ylwcj30he0dumxf.jpg" alt="image-20200308230730423"></p>
<p>WindowState 产生了他自己这个窗口的layer值后.在添加窗口的时候就会把所有窗口按layer排序插入mWindows列表中,在通过 adjustWallpaperWindowsLocked();进行层级调整.</p>
<h2 id="窗口的布局"><a href="#窗口的布局" class="headerlink" title="窗口的布局"></a>窗口的布局</h2><p>当客户端通过IWindowsession.add后,客户端还没有获得Surface.只有在执行IWindowsession.relayout后.客户端才获得了一块Surface. IWindowsession.relayout根据客户端提供的参数,为客户端提供surface.具体实现是WMS.relayoutWindow</p>
<h3 id="WMS-relayoutWindow"><a href="#WMS-relayoutWindow" class="headerlink" title="WMS.relayoutWindow"></a>WMS.relayoutWindow</h3><ol>
<li>方法参数的介绍</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr62958c8j30se0j5gq1.jpg" alt="image-20200308232324270"></p>
<ol start="2">
<li>所在mWindowMap.防止多线程竞争</li>
<li>找到需要进行relayout 的窗口对应的windowState</li>
<li>遍历所有DispalyContent的所有窗口,计算布局尺寸,并把尺寸设置给Surface</li>
<li>把布局结果返回给用户端.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int relayoutWindow(Session session, IWindow client, int seq,</span><br><span class="line">            WindowManager.LayoutParams attrs, int requestedWidth,</span><br><span class="line">            int requestedHeight, int viewVisibility, int flags,</span><br><span class="line">            Rect outFrame, Rect outContentInsets,</span><br><span class="line">            Rect outVisibleInsets, Configuration outConfig, Surface outSurface) &#123;</span><br><span class="line">      参数里的outSurface最后就是传递给客户端的surface.他会和客户端的surface进行绑定.然后客户端就可以绘制了.</span><br><span class="line">   </span><br><span class="line">  synchronized(mWindowMap) &#123;</span><br><span class="line">        //获得要relayout的窗口   </span><br><span class="line">        WindowState win = windowForClientLocked(session, client, false); </span><br><span class="line">        //下边是对win各种属性的更新.</span><br><span class="line">        ...</span><br><span class="line">        //遍历所有DispalyContent的所有窗口,计算布局尺寸,并把尺寸设置给Surface</span><br><span class="line">         performLayoutAndPlaceSurfacesLocked();</span><br><span class="line">         //把布局结果返回给用户端</span><br><span class="line">           outFrame.set(win.mCompatFrame);</span><br><span class="line">            outContentInsets.set(win.mContentInsets);</span><br><span class="line">            outVisibleInsets.set(win.mVisibleInsets);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是根据用户传入的参数,更新WindowState.然后遍历所有窗口布局.在设置合适的Surface尺寸,在返回给用户端</p>
<p>performLayoutAndPlaceSurfacesLocked 会循环调用6次.里边的逻辑大概如下</p>
<ol>
<li>清除已退出或已隐藏的僵尸窗口的surface</li>
<li>又调用其他方法进行布局</li>
<li>如果需要.再次重复布局操作.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">performLayoutAndPlaceSurfacesLockedLoop&#123;</span><br><span class="line">	1清除已退出或已隐藏的僵尸窗口的surface</span><br><span class="line">	 for (int i=0; i&lt;mForceRemoves.size(); i++) &#123;</span><br><span class="line">      WindowState ws = mForceRemoves.get(i);</span><br><span class="line">      removeWindowInnerLocked(ws.mSession, ws);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);</span><br><span class="line">  //如果需要.再次重复布局</span><br><span class="line">  if (needsLayout()) &#123;</span><br><span class="line">        if (++mLayoutRepeatCount &lt; 6) &#123;</span><br><span class="line">            requestTraversalLocked();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要下,因为之前加了锁.requestTraversalLocked他又会重复执行performLayoutAndPlaceSurfacesLocked();因此会重复循环执行布局.</p>
<p>布局这部分就记个原理吧</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr62ai2erj30l409baas.jpg" alt="image-20200308234415722"></p>
<p>布局完成后.客户端的尺寸和surface都得到了.就可以绘制 了.WMS会通知客户端布局发送变化</p>
<p>总结,WMS 负责管理所有的窗口.包括系统窗口和APP窗口,而窗口必须有一个WindowToken所为标识符.同时WMS为每个窗口创建一个WindowState类,这是窗口在服务端的抽象.WindowState则绑定了一个客户端的IWindow类,WMS通过这个IWindow 向APP发送消息.</p>
<p>AMS在启动Activity的时候.把ActivityRecord.token 通过wms.addtoken 注册到WMS.又把这个token发送到APP端.因此三方可以通过这个token正确找到对应的数据.</p>
<p>WMS负责给所以窗口按ZOrder排序,确定窗口的尺寸,提供绘画用的surface.</p>
<p>Activity的窗口是先wms.addtoken 建立windowToken关系 . wms.addWindow. 添加串口, WMS.relayout获取surface. 完成 .</p>
<p>一个windowToken对应一个Activity. 但是可能对应多个windowSatate.也就是对应多个窗口.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr629yupej30m80en75k.jpg" alt="image-20200309193604451"></p>
<h1 id="安卓控件系统"><a href="#安卓控件系统" class="headerlink" title="安卓控件系统"></a>安卓控件系统</h1><h2 id="基础类介绍"><a href="#基础类介绍" class="headerlink" title="基础类介绍"></a>基础类介绍</h2><h3 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h3><p>  是view树的根实现类是viewRootImpl.但是他不是view.他是用来和WMS进行交流的管理者.viewRootImpl内部有个IWindowSession,是WMS提供的匿名binder,同时还有个iWindow子类,用来让WMS给viewr发消息. view通过ViewRoot向WMS发消息.WMS在通过IWIndow 向APP发消息. 每个View树只有一个ViewRoot,每个Activity也只有一个ViewRoot. UI绘制,事件传递.都是通过ViewRoot.  </p>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>.实现类是PhoneWindow . Activity和View的沟通就是通过Window.Activity实现window的各种回调.一个Activity也对应一个PhoneWindow.也对应一个View树.</p>
<p>Docerview 就是View树的根.这是一个View. 他由PhoneWindow管理. 下文的WindowManager也由phoneWindow管理. </p>
<p>他还管理window的属性 WindowManager.layoutparams.</p>
<h3 id="windowManager"><a href="#windowManager" class="headerlink" title="windowManager"></a>windowManager</h3><p> 他是一个代理类.他集成自ViewManager.他的实现是WindowManagerImpl.这是每个Activity都有一个.但是他只是把工作委托给了 WindowManagerGlobal来实现. 他负责添加删除窗口,更新窗口.并控制窗口的补件属性WindowManager.Layoutparams.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr625ev1uj30f808taai.jpg" alt="image-20200310123836737"></p>
<h3 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h3><p> 是进程唯一的.负责这个进程的窗口管理.他里边有三个集合.保存这个进程所有窗口的数据.这里的每个数据根据index得到的是同一个Activity属性.所有的WindowManager的操作都转到他这里来.</p>
<p> private final ArrayList<view> mViews   每个view是个跟节点</view></p>
<p> private final ArrayList<viewrootimpl> mRoots  view对应的viewRoot </viewrootimpl></p>
<p> private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams  窗口的layoutparams属性.每个窗口一个</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr62bwk5uj30r70l1mzp.jpg" alt="image-20200309202306828"></p>
<p>对于一个acitivity对象永远对应一个PhoneWindow,一个WindowManagerImpl,一个WMS端的APPWindowToken,一个AMS里的ActivityRecord(但是如果一个activity在栈里有多个对象,就有多个ActivityRecord和AppWindowToken),acitvity 的默认窗口的view树是DocerView.</p>
<p>一个窗口 对应一个ViewRoot,一个View树.一个WindowManager.LayoutParams,一IWindow(WMS回调app).一个WSM端的WindowSatate.</p>
<p>但是一个Activity可以有多个窗口,因此对应WMS里可能有多个WindowSatate.这些WindowState都对应一个AppWindowToken.</p>
<p>一个Activity可能被加载多次.因此在AMS中可能有多个ActivityRecord对应这个activit的多个对象.</p>
<p>但是一个进程则对应一个WindowManagerGlobal.一个ActivityThread(主线程).一个ApplicationThread(AMS调用app).一个iWindowSession(viewroot向WMS发消息)</p>
<p>这里的区别就是 app与AMS 的交互是以进程之间进行通信.而App与WMS的交互.则是以窗口作为通信基础.</p>
<h2 id="窗口添加过程"><a href="#窗口添加过程" class="headerlink" title="窗口添加过程"></a>窗口添加过程</h2><p>当Activity由AMS启动时.ActivityThread 通过handleResumeActivity执行resume相关的操作.这个函数首先是执行activity.resume, 此时activity 对应的view树已经建立完成(oncreate中建立,PhoneWindow也创建了).需要把activity的窗口添加到WMS中去管理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,</span><br><span class="line">            boolean reallyResume) &#123;</span><br><span class="line">				//执行onresume</span><br><span class="line">        ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">   ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        if (a.mVisibleFromClient) &#123;</span><br><span class="line">            a.mWindowAdded = true;</span><br><span class="line">            //添加daoWMS中</span><br><span class="line">            wm.addView(decor, l);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的wm是WindowManager.是每个activity一个.他内部会调用WindowManagerGlobal.addView</p>
<p>WindowManagerGlobal.addView</p>
<p>这里会为窗口创建ViewRootImpl. 并把view.ViewRootImpl.WindowMa.LayoutParams都保存在WindowManagerGlobal中, 并通过ViewRootImpl向WMS添加窗口</p>
<p>如果这个窗口是子窗口(wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;<br>                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW)</p>
<p>就把子窗口的token设为父窗口的token否则就是所属activity的token.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,</span><br><span class="line">           Display display, Window parentWindow) &#123;</span><br><span class="line">   final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">   </span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">	 mViews.add(view);</span><br><span class="line">           mRoots.add(root);</span><br><span class="line">           mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">           // do this last because it fires off messages to start doing things</span><br><span class="line">           try &#123;</span><br><span class="line">               root.setView(view, wparams, panelParentView);</span><br><span class="line">           &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在来个图</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr62azldjj30eh088aaw.jpg" alt="image-20200310151303616"></p>
<p>在这里我们看到.我们通过mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); 拿到的并不是远程的WMS.而是本地的WindowManagerImpl. 他又把请求转发给WindowManagerGlobal ,而WindowManagerGlobal作为进程单实例.又是吧请求转给对应窗口的ViewRootImpl.ViewRootImpl通过WMS的IWindowSession 把数据发给WMS.</p>
<h3 id="理解ViewRootImpl"><a href="#理解ViewRootImpl" class="headerlink" title="理解ViewRootImpl"></a>理解ViewRootImpl</h3><p>ViewRootImpl用来沟通View和WMS.并接受WMS的消息.这是双向的binder通信.作为整个空间树的根部,控件的测量,布局,绘制,输入时间的派发都由ViewRootImpl来触发.</p>
<p>ViewRootImpl由WindowManagerGlobal创建,是在activityThread.handleResumeActivity时,先执行activity.resume.在调用wm.addView. 就会执行WindowManagerGlobal.addView里.创建ViewRootImpl,此时是在ui线程中.</p>
<p>ViewRootImpl里的mView属性.host属性,就是view树</p>
<h3 id="ViewRootImpl-创建"><a href="#ViewRootImpl-创建" class="headerlink" title="ViewRootImpl 创建"></a>ViewRootImpl 创建</h3><ol>
<li>得到WMS里的IWindowSession代理.</li>
<li>保存display.表示一块屏幕.之后view绘制在这上.</li>
<li>保存当前线程,也就是ui线程</li>
<li>保存当前窗口尺寸.</li>
<li>W类是WMS回调APP的binder</li>
<li>attachInfo表示view树所依附的窗口的信息,会传递给每个view</li>
<li>主线程中创建Choreographer,用于接收重绘信号.</li>
<li>用于向主线程发消息的mHandler</li>
<li>用于绘制的surface. 会和WMS返回的surface绑定.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ViewRootImpl(Context context, Display display) &#123;</span><br><span class="line">        得到WMS里的IWindowSession代理.</span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        保存绘制的屏幕</span><br><span class="line">        mDisplay = display;</span><br><span class="line">      </span><br><span class="line">        保存ui线程</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        mDirty = new Rect();</span><br><span class="line">        //窗口尺寸</span><br><span class="line">        mTempRect = new Rect();</span><br><span class="line">        //WMS回调APP的binder</span><br><span class="line">         mWindow = new W(this);</span><br><span class="line">        //表示当前view树所依附的窗口的信息,会给每个view</span><br><span class="line">        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this,context);</span><br><span class="line">       //主线程中创建Choreographer,用于接收重绘信号.</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        ///依附于主线程.发消息到主线程执行.</span><br><span class="line">        final ViewRootHandler mHandler = new ViewRootHandler();</span><br><span class="line">        </span><br><span class="line">    public final Surface mSurface = new Surface();</span><br></pre></td></tr></table></figure>

<h3 id="ViewRootImpl-setView-注册窗口"><a href="#ViewRootImpl-setView-注册窗口" class="headerlink" title="ViewRootImpl.setView 注册窗口"></a>ViewRootImpl.setView 注册窗口</h3><ol>
<li>保存view树</li>
<li>添加到WMS前的重绘操作,这次的结果可能会被WMS的回调进行修改.但是重绘必不可少</li>
<li>向WMS注册窗口.</li>
<li>ui线程注册完成输入事件的注册.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">		//保存控件树</span><br><span class="line">		 mView = view;</span><br><span class="line">		 //添加到WMS前的重绘操作</span><br><span class="line">	  requestLayout();</span><br><span class="line">	  inputChannel是一个接受输入事件的管道.用来接收输入事件.</span><br><span class="line">	   mInputChannel = new InputChannel();</span><br><span class="line">	  //向WMS注册窗口</span><br><span class="line">	   res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">           getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">           mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">           mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">   //这里是输入事件的接收者,传入的looper.myLooper是ui线程的looper.因此输入事件在ui线程触发.这里了解吧</span><br><span class="line">  </span><br><span class="line">  if (mInputChannel != null) &#123;</span><br><span class="line">       if (mInputQueueCallback != null) &#123;</span><br><span class="line">           mInputQueue = new InputQueue();</span><br><span class="line">           mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">       &#125;</span><br><span class="line">       mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,</span><br><span class="line">               Looper.myLooper());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr626tj15j30fh06jglz.jpg" alt="image-20200310162246302"></p>
<h3 id="ViewRootImpl-performTraversals-重绘"><a href="#ViewRootImpl-performTraversals-重绘" class="headerlink" title="ViewRootImpl.performTraversals 重绘"></a>ViewRootImpl.performTraversals 重绘</h3><p>添加窗口时通过requestLayout();向ui线程发送消息.最后回调到ViewRootImpl.performTraversals.他是整个ui控件树,measure.layout.draw的集合.</p>
<p>这里分为五个阶段.</p>
<p>预测量阶段.进行第一次测量,获得view.getMeasuredWitdh/Height,此时是控件树期望的尺寸.会执行View的onMeasure</p>
<p>布局阶段,根据预测量的结果,通过IWindowSession.relayout向WMS请求调整窗口的尺寸这会使WMS对窗口重新布局,并把结果返回给ViewRootImpl.</p>
<p>最终测量阶段, 预测量的结果是view树期望的结果.WMS可能会进行调整,在这里WMS已经把结果通知了ViewRootImpl.因此这里会窗口实际尺寸performTraversals进行布局.view及子类的onMeasure会被回调</p>
<p>布局阶段. 测量完成后获得空间的尺寸,布局要确定控件的位置,View及子类的onLayout会被回调.</p>
<p>绘制阶段,使用WMS提供的surface.进行绘制,View及子类的onDraw会被回调.</p>
<p>通常我们看到的都是 先measure,在layout在draw. 这里看到.其实measure先得到期望值,在和WMS沟通.WMS在调整后,返回确定值,在根据确定值进行mesure.</p>
<h4 id="预测量"><a href="#预测量" class="headerlink" title="预测量"></a>预测量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line"> 	窗口的最新尺寸</span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    </span><br><span class="line">    if (mFirst) &#123;//第一次遍历.窗口刚添加到WMS.还没有有效的窗口尺寸.</span><br><span class="line">    			//使用屏幕的尺寸.</span><br><span class="line">    		    mDisplay.getRealSize(size);</span><br><span class="line">           desiredWindowWidth = size.x;</span><br><span class="line">           desiredWindowHeight = size.y;</span><br><span class="line">        //通过view书跟节点.执行 attach 每个view都会回调onAttachedToWindow();  </span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">    	//不是第一次.并且窗口尺寸和Viewrootimpl不一样.表现需要重新测量.</span><br><span class="line">       desiredWindowWidth = frame.width();</span><br><span class="line">       desiredWindowHeight = frame.height();</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line">    //处理view.post(runnable) 也就是借着ViewRootimpl的hanlder发送给ui线程执行.</span><br><span class="line">    这个RunQue是进程唯一的.</span><br><span class="line">    getRunQueue().executeActions(mAttachInfo.mHandler); </span><br><span class="line">    </span><br><span class="line">    //进行预测量.</span><br><span class="line">    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                         desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>measureHierarchy里会通过三次协商.执行performMeasure 来确认合适的尺寸.</p>
<p>performMeasure 会调用view 的measure 优会调用onMeasure. 我们可重写onMeasure来实现测量.而measure 方法是final的.onMeasure 的结果通过setMeasuredDimension方法保存.</p>
<p>对于view. onMeasure.比较容易. 对于ViewGroup.则还要遍历调用他所以子view的measure. 并且需要考虑padding和子view 的margin. padding是控件外内边距. margin 是控件外边距.</p>
<p>ViewGroup需要先测量完子view.在根据子view的测量值得到自己的宽高.举例,如果只有一个子view.那么ViewGroup的宽= 子view的宽+子view的margin+viewg的padding.  至少是这个值.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr624gp93j30fz0brgmp.jpg" alt="image-20200310205221080"></p>
<p>继续回到performTraversals</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">boolean windowShouldResize  //决定是否窗口要改变尺寸.至此.预测量完成</span><br></pre></td></tr></table></figure>

<p>这里就是提前测量了一下.得到控件树希望的尺寸大小,</p>
<h4 id="布局窗口和最终测量"><a href="#布局窗口和最终测量" class="headerlink" title="布局窗口和最终测量"></a>布局窗口和最终测量</h4><p>通过relayoutWindow来布局窗口. ViewRootImpl 通过IWindowSession 来通知WMS进行窗口布局.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,</span><br><span class="line">           boolean insetsPending)&#123;</span><br><span class="line"> 	 int relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">               (int) (mView.getMeasuredWidth() * appScale + 0.5f),</span><br><span class="line">               (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility,</span><br><span class="line">               insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, frameNumber, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,mPendingMergedConfiguration, mSurface);          </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要下. 调用WMS后.WMS会调整窗口的尺寸. 同时会生成surface返回给ViewRootImpl. 因此后续的绘画就有了画布了.可以看到最后的参数是mSurface.这是本地的surface. 这里会和wms的进行绑定.</p>
<p>接下来继续performTraversals,绑定WMS返回的surface.然后更新尺寸.</p>
<p>最后进行最终测量. 上边过程太乱了. 了解下就行.还是看常见的控件绘制流程.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr626c0ctj315g0jq77j.jpg" alt="image-20200310213030039"></p>
<h3 id="viewRootImpl-performTraversals"><a href="#viewRootImpl-performTraversals" class="headerlink" title="viewRootImpl.performTraversals"></a>viewRootImpl.performTraversals</h3><p>绘制由viewRootImpl.performTraversals触发, 抽取出来后,就是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals()&#123;</span><br><span class="line">		performConfigurationChange()  //会触发onConfigurationChange事件</span><br><span class="line">		//这时候传入的是屏幕的尺寸</span><br><span class="line">  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">	</span><br><span class="line">	//用测量完的高度.在进行补件  host是view树的跟布局</span><br><span class="line">	 int width = host.getMeasuredWidth();</span><br><span class="line">   int height = host.getMeasuredHeight();</span><br><span class="line">	 performLayout(lp, mWidth, mHeight);	</span><br><span class="line">	 </span><br><span class="line">	 //绘制流程. 此时WMS返回的surface已和ViewRootImpl的surface绑定了起来.可以进行绘制了.</span><br><span class="line">	  performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="viewRootImpl-performMeasure"><a href="#viewRootImpl-performMeasure" class="headerlink" title="viewRootImpl.performMeasure"></a>viewRootImpl.performMeasure</h3><p>就是直接调用view树的根的measure方法. 传入到View</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr6230nzzj30l80o2wgg.jpg" alt="image-20200311122109134"></p>
<h4 id="View-measure"><a href="#View-measure" class="headerlink" title="View.measure"></a>View.measure</h4><p>该方法是final .意味着无法重写.这里又会调用onMeasure.</p>
<p>因此.对于view.在onMeasure中调整好高度,通过setMeasuredDimension设置好自己的测量宽高就可以了.</p>
<p>对应ViewGroup.则在onMeasure中,先要遍历子view.调用他们的measure(注意一定是调用子类的measure,measure又会调用onMeasure), 子view宽高都知道后,在根据子view的宽高来设置自己.也就是ViewGroup的宽高受子view影响.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">		onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">               getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">这里的widthMeasureSpec由两部分组成,模式mode和值size.都由父view提供</span><br><span class="line">模式有三种</span><br><span class="line">unspecified 父view不限制ziview大小.多用于系统内部</span><br><span class="line">exactly	精确值,子view的大小就是widthMeasureSpec的size,对应子view的match_parent 和确定值这两种</span><br><span class="line">at_most	父view提供可用大小,既widthMeasureSpec的size,子view不超过这个值就可以.对应子view的wrap_content</span><br></pre></td></tr></table></figure>

<p>可以看到view的measure又调用了onMeasure, 如果是view 则可以直接重新onMeasure来设定大小.而对于ViewGroup, 则需要重写onMeasure来先遍历子view.设定大小.然后再设定viewGroup的大小. ViewGroup并没有重写onMeasure.因为每个ViewGroup要实现的效果不同,需要自己完成.但ViewGroup提供了几个方法供ViewGroup的继承类来遍历子view.</p>
<p>view的宽高由自己的layoutParams和父view提供的 widthMeasureSpec|heightMeasureSpec共同决定.</p>
<p>View 自己的宽高,是保存在LayoutParams中对,以宽举例 LayoutParams.width 有三种情况,精确值(就是指定大小),MATCH_PARENT. WRAP_CONTENT,模式则有fuview提供.有 unspecified,exactly,at_most三种.</p>
<p>匹配如下.</p>
<p>​     <img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr624xpu5j30ll09jdgu.jpg" alt="image-20200311122806999"></p>
<p> 其实这个很好理解. 如果子view自己指定了宽高.就用他的值就可以.如果子view是match_parent.那就使用父view提供的宽高. 如果子view是wrap_content,那就不能超过父view的值.</p>
<p>看下ViewGroup为子view绘制而提供的方法,可以看到.ViewGroup会减去padding和margin,来提供子view的宽高.</p>
<h4 id="viewgroup-measureChildWithMargins"><a href="#viewgroup-measureChildWithMargins" class="headerlink" title="viewgroup.measureChildWithMargins"></a>viewgroup.measureChildWithMargins</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">        int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">        int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Framelayout-onMeasure"><a href="#Framelayout-onMeasure" class="headerlink" title="Framelayout.onMeasure"></a>Framelayout.onMeasure</h4><ol>
<li>遍历子view.通过ViewGroup提供的measureChildWithMargins拿到子view的宽高.并用最大值作为framelayout的宽高</li>
<li>最大值在加上framelayout的padding</li>
<li>通过setMeasureDemision 来设置framelayout的宽高        </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int count = getChildCount();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int maxHeight = 0;</span><br><span class="line">        int maxWidth = 0;</span><br><span class="line">//遍历子view.通过ViewGroup提供的measureChildWithMargins拿到子view的宽高.</span><br><span class="line">并用最大值作为framelayout的宽高</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = getChildAt(i);</span><br><span class="line">            if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">                final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">                maxWidth = Math.max(maxWidth,</span><br><span class="line">                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">                maxHeight = Math.max(maxHeight,</span><br><span class="line">                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//最大值在加上framelayout的padding</span><br><span class="line">        // Account for padding too</span><br><span class="line">        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">        // Check against our minimum height and width</span><br><span class="line">        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">通过setMeasureDemision 来设置framelayout的宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                        childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewRootImpl-performLayout"><a href="#ViewRootImpl-performLayout" class="headerlink" title="ViewRootImpl.performLayout"></a>ViewRootImpl.performLayout</h4><p> 上步measure过程未完成后,整个view书的 测量宽高都得到了.也就是view.getMeasuredWidth()和getMeasuredHeight()</p>
<p>performLayout中会调用mView.layout. 这样就把事件从ViewRootImpl传递到了view.而layout中又会调用onLayout.ViewGroup需要重写onLayout为子view进行布局,遍历调用子view的layout.因此就完成整个view树的laylut过程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">            int desiredWindowHeight) &#123;</span><br><span class="line">   //host就是view书的根view.对与activity就是docerView</span><br><span class="line">   //这里传入的参数就是measure 过程测量出的view的宽高.作为左上右下的左边传给layout</span><br><span class="line">   host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="view-layout"><a href="#view-layout" class="headerlink" title="view.layout"></a>view.layout</h4><ol>
<li>通过setframe设定view本身的布局位置,这里都是以fuview左上角作为标点.</li>
<li>调用onLayout. 整个方法在view中是空的.这是给ViewGroup用来布局子view的.</li>
<li>onLayout 和具体布局有关.viewGroup也没有实现,而是具体的ViewGroup的集成类自己实现.ViewGroup的onLayout是抽象方法.必须要子类实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line"></span><br><span class="line">	  boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">	onLayout(changed, l, t, r, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LinearLayout-onLayout"><a href="#LinearLayout-onLayout" class="headerlink" title="LinearLayout.onLayout"></a>LinearLayout.onLayout</h4><p>竖向的实现, 竖向的就行把view从上到下一次排开</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void layoutVertical(int left, int top, int right, int bottom) &#123;</span><br><span class="line">        final int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        int childTop;</span><br><span class="line">        int childLeft;</span><br><span class="line"></span><br><span class="line">        // ViewGroup的宽度</span><br><span class="line">        final int width = right - left;</span><br><span class="line">        int childRight = width - mPaddingRight;</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line">        childTop = mPaddingTop;</span><br><span class="line"></span><br><span class="line">				//因为是从上到下排开,计算每个view的top值,top值就是view.getMeasureHeigh+view.		topMargin+view.bottomPargin +LinearLayout的paddingTop</span><br><span class="line">				所以这里的子view的top值是不断变大.因此.view就依次从上到下摆开了.</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">             if (child.getVisibility() != GONE) &#123;</span><br><span class="line">                final int childWidth = child.getMeasuredWidth();</span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">                final LinearLayout.LayoutParams lp =</span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">                childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line"></span><br><span class="line">                childTop += lp.topMargin;</span><br><span class="line">                设置ziview的四个角的坐标.调用子view的layout.重复layout过程.</span><br><span class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                        childWidth, childHeight);</span><br><span class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里注意区分.measure过程是先得到子view的测量值,在设定父ViewGroup的值.而layout过程则是先传入父view的左上右下值,来计算子view的左上右下的位置值.这里应该具有普遍性.但不知道是否绝对.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr627nhagj30ou0oetaq.jpg" alt="image-20200311123219084"></p>
<h4 id="ViewRootImpl-performDraw"><a href="#ViewRootImpl-performDraw" class="headerlink" title="ViewRootImpl.performDraw"></a>ViewRootImpl.performDraw</h4><p>performDraw 中的调用draw.又调用mView.draw.然后就进入view树的绘制了.</p>
<p>view的draw 又会调用onDraw ,viewGroup又调用dispatchDraw()把draw分发到子view里 绘制的画布就是canvas. 这是从surface.lockCanvas中获得的一个区域.</p>
<p>而在ViewGroup.dispatchDraw中.重要的一点是getChildDrawingOrder 表示子view的绘制顺序.默认是与ziview的添加顺序一样.我们也可以改变他.最后绘制的会显示在最上边,而这也影响view的事件传递顺序.</p>
<p>view.draw. 就是一层一层的画内容.先画北京,在onDraw.在画装饰什么的.</p>
<h3 id="控件树绘制讲解"><a href="#控件树绘制讲解" class="headerlink" title="控件树绘制讲解"></a>控件树绘制讲解</h3><p>canvas.translate(100,300)通过平移坐标系.使之后的内容可以直接在新坐标系中绘制.</p>
<p>这就是ViewGroup在向子view传递canvas的时候.方便多了. 会之前先对其ziview的左上角.那么子view就可以直接从自己坐标轴的(0,0)开始绘制, 绘制完成后ViewGroup在还原原有坐标系.</p>
<p>canvas.save. canvas.restore 用来保存还原坐标系.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr625vo6dj309e0463yl.jpg" alt="image-20200311142226071"></p>
<p>view.invalidate.</p>
<p>当某个view发送变化需要重绘时,通过view.invalidate向上通知到ViewRootImpl.从这个view到ViewRootImpl的节点都标记为藏区域.dirty area. ViewRootimpl再次从上到下重绘时,只绘制这些脏区域.效率高.</p>
<h2 id="输入事件派发"><a href="#输入事件派发" class="headerlink" title="输入事件派发"></a>输入事件派发</h2><h3 id="触摸模式"><a href="#触摸模式" class="headerlink" title="触摸模式"></a>触摸模式</h3><p>本来安卓兼容使用键盘,也支持,触摸.二者的输入事件派发不一样.使用键盘时会有个控件处于获得焦点状态.处于触摸模式则由用户决定. 因此控件分为两类.任何情况下都能获得焦点.如输入文本框.只有在键盘操作时才能获得焦点.如菜单,按钮.</p>
<p>安卓里有触摸模式.当发送任意触摸时进入触摸模式.当发送方向键和键盘或者执行View.requestRocusFromTouch时,退出触摸模式.</p>
<h4 id="View-requestFocus"><a href="#View-requestFocus" class="headerlink" title="View.requestFocus"></a>View.requestFocus</h4><p>获取焦点. view.request.</p>
<p>先检查是否能获取焦点,</p>
<p>然后设置获取简单的标记,</p>
<p>向上传递到ViewRootimpl.保证只能有一个控件获取焦点.</p>
<p>通知焦点变化的监听者.</p>
<p>更新view的drawable状态,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) &#123;</span><br><span class="line"></span><br><span class="line">       if ((mPrivateFlags &amp; PFLAG_FOCUSED) == 0) &#123;</span><br><span class="line">           mPrivateFlags |= PFLAG_FOCUSED;</span><br><span class="line"></span><br><span class="line">           View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;</span><br><span class="line"></span><br><span class="line">           if (mParent != null) &#123;</span><br><span class="line">               mParent.requestChildFocus(this, this);</span><br><span class="line">               updateFocusedInCluster(oldFocus, direction);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (mAttachInfo != null) &#123;</span><br><span class="line">               mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           onFocusChanged(true, direction, previouslyFocusedRect);</span><br><span class="line">           refreshDrawableState();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>requestChildFocus会把焦点事件层层上报取消原来有焦点的控件.最后的效果就是从viewrootimpl中.到最终有焦点的view.构成一条 mFoucued 标识的链条.来个图就明白了.每个view的mFocused总是指向他的直接下级.</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr6277nh0j30fs07h0t1.jpg" alt="image-20200311150906174"></p>
<p>获取focus的传递是从底层view到顶层的ViewRootImpl.而取消focus测试从顶层的ViewRootimpl到底层原来那个获得焦点的view.</p>
<h4 id="ViewGroup-requestFocus"><a href="#ViewGroup-requestFocus" class="headerlink" title="ViewGroup.requestFocus"></a>ViewGroup.requestFocus</h4><p>而如果是ViewGroup请求获取焦点,会根据FLAG_MASK_FOCUSABILITY特性来做不同方式,分别有先让自己获取焦点,或者安卓view的索引递增或者递减来匹配view.</p>
<h3 id="事件派发"><a href="#事件派发" class="headerlink" title="事件派发"></a>事件派发</h3><p>ViewRootImpl 中的.WindowInputEventReceiver接受输入事件.他会把事件包装成一个QueuedInputEvent.然后追加到一个单链表的末尾.接着重头到尾的处理输入事件,并通过deliverInputEvent完成分发.这里会把单链表所有事件都处理完.</p>
<p>deliverInput中又会把触摸事件执行到通过 ViewPreImeInputStage.processKeyEvent. 转入mView.dispatchPointerEvent(event).这里又进入 dispatchTouchEvent</p>
<p>MotionEvent是触摸事件的封装.getAction可以拿到动作的类型和触控点索引号.</p>
<p>getX(),getY().拿到动作的位置信息.通过getPointID拿到触控点的id. 动作以down 开头.跟多个move.最后是up.</p>
<h4 id="view-dispatchTouchEvent"><a href="#view-dispatchTouchEvent" class="headerlink" title="view.dispatchTouchEvent"></a>view.dispatchTouchEvent</h4><p>,当事件返回true.表示事件被消费掉了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">	//安全模式.不允许窗口被遮挡.</span><br><span class="line">	if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //回调listener的ontouch</span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">				//回调onTouchEvent</span><br><span class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ViewGroup-dispatchTouchEvent"><a href="#ViewGroup-dispatchTouchEvent" class="headerlink" title="ViewGroup.dispatchTouchEvent"></a>ViewGroup.dispatchTouchEvent</h4><p>因为有多点触控.ViewGroup可能把motionevent拆成多个事件,分发给多个ziview.因此他内部的mFirstTouchTarget是单向链表.存储所有要处理事件的子view.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">		//同样.对窗口遮挡进行检查.</span><br><span class="line">	 if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">	 		 down是事件开始.清楚原有的状态.</span><br><span class="line">	 		if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">          cancelAndClearTouchTargets(ev);</span><br><span class="line">          resetTouchState();</span><br><span class="line">      &#125;</span><br><span class="line">      //是否子view阻止ViewGroup进行事件拦截,不阻止的话,ViewGroup判断是否拦截.</span><br><span class="line">      //ViewGroup可以拦截事件.但是里边的子view也可以不然ViewGroup拦截.并且子view的权限更高.</span><br><span class="line">	 	 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">        if (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">            ev.setAction(action); // restore action in case it was changed</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            intercepted = false;</span><br><span class="line">        &#125;</span><br><span class="line">       if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">					事件派发.获取触控点和索引号</span><br><span class="line">          final int actionIndex = ev.getActionIndex();</span><br><span class="line">       		final View[] children = mChildren;</span><br><span class="line">       		//遍历子view.找到适合派发事件的view.进行派发</span><br><span class="line">          for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">          //进行事件派发,如果成功,就把这个子view加入到mFirstTouchTarget中.之后的move等事件直接派发.</span><br><span class="line">           if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">              mLastTouchDownX = ev.getX();</span><br><span class="line">              mLastTouchDownY = ev.getY();</span><br><span class="line">              newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">              alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">              break;</span><br><span class="line">	          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">       &#125; </span><br><span class="line">       </span><br><span class="line">       如果最后子view没有处理事件.则要把时间交给ViewGroup自己.这样又层层上报了回来.</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatchTransformedTouchEvent这又会调用子view的dispatchTouchEvent.进行派发.这样事件就从ViewRootImpl逐渐派发到底了.同时会保存执行down事件的view.之后的move.up事件都有他来处理.</p>
<h3 id="理解PhoneWindow"><a href="#理解PhoneWindow" class="headerlink" title="理解PhoneWindow"></a>理解PhoneWindow</h3><p>phonewindow是与activity 一对一匹配的.是在ActivityThread执行 performLaunchActivity.activity创建后执行activit.attach的时候生成的.他管理view树,各种事件回调.和WindowManager.layoutparams. 用来提供简单的方法创造activity的外观. activity.setcontentView. 就是调用PhoneWindow.setContentView. 而我们传入的layout. 只是作为view树的一个子view. PhoneWindow管理的view书是DocerView. ViewRootImpl里的mView也是他.他作为跟控件.把很多回调交给了PhoneWindow.</p>
<p>比如在dispatcTochEvent 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Window.Callback cb = mWindow.getCallback();final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event): super.dispatchKeyEvent(event);</span><br></pre></td></tr></table></figure>

<p>直接交给. Window.callback处理.这个callback就是activity了.看看activity中的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">      if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">          onUserInteraction();</span><br><span class="line">      &#125;</span><br><span class="line">      //这里又调用了DockerView的super.dispatchTouchEvent.也就是交还控件树处理.</span><br><span class="line">      if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      如果控件树没有处理.则返回给activity在处理.</span><br><span class="line">      return onTouchEvent(ev);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因此.activity的dispatchTouchEvent 是先于控件树触发的.我们可以重写这个方法来实现我们的功能.</p>
<p>activity在创建后.现在执行 attach.初始化一写本地参数.如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">           Instrumentation instr, IBinder token, int ident,</span><br><span class="line">           Application application, Intent intent, ActivityInfo info,</span><br><span class="line">           CharSequence title, Activity parent, String id,</span><br><span class="line">           NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">           Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">           Window window, ActivityConfigCallback activityConfigCallback) &#123;</span><br><span class="line">      	先创建PhoneWindow.     </span><br><span class="line">       mWindow = new PhoneWindow(this, window, activityConfigCallback);</span><br><span class="line">       //设置activity作为事件回调.</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        //和WMS交流的token</span><br><span class="line">         mToken = token;</span><br><span class="line">        //拿到windowManager</span><br><span class="line">        mWindow.setWindowManager(</span><br><span class="line">               (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">               mToken, mComponent.flattenToString(),</span><br><span class="line">               (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>attach之后.activity就有了和WMS交流的 PhoneWindow.WindowManager.和WMS交互的token记着这个token来自AMS. 但是在这之前AMS已经把这个token注册到WMS中.因此此时可直接使用.</p>
<p>Activity的显示发送在onResume之后,由ActivithThread.handlerResumeActivity触发.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,</span><br><span class="line">  boolean reallyResume) &#123;</span><br><span class="line">	//执行activity.onresume</span><br><span class="line"> ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">              r.window = r.activity.getWindow();</span><br><span class="line">              View decor = r.window.getDecorView();</span><br><span class="line">              //此时窗口还没注册.所以没有显示出来.</span><br><span class="line">              decor.setVisibility(View.INVISIBLE);</span><br><span class="line">              ViewManager wm = a.getWindowManager();</span><br><span class="line">              WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">              a.mDecor = decor;</span><br><span class="line">              l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">              l.softInputMode |= forwardBit;</span><br><span class="line">              //这里通过WindowManager-windowmanagerglobal-viewrootImp,把窗口注册到WMS</span><br><span class="line">              if (a.mVisibleFromClient) &#123;</span><br><span class="line">                  a.mWindowAdded = true;</span><br><span class="line">                  wm.addView(decor, l);</span><br><span class="line">              &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    		//wms里注册完成.让页面展示出来.</span><br><span class="line">    	  if (!r.activity.mFinished &amp;&amp; willBeVisible</span><br><span class="line">                  &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">                  </span><br><span class="line">               if (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                  r.activity.makeVisible();</span><br><span class="line">              &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="Activity-启动整体流程"><a href="#Activity-启动整体流程" class="headerlink" title="Activity 启动整体流程"></a>Activity 启动整体流程</h1><p>startActivity开始时会通过ActivityManagerNative.getDefault().startActivity调用AMS开始.又跳转到了ActivityStack.startActivityMayWait.我们从这里分析.</p>
<p>ActivityStack.startActivityMayWait</p>
<ol>
<li>通过packageManager解析intent得到ResolveInfo</li>
</ol>
<p>ResolveInfo rInfo =AppGlobals.getPackageManager().resolveIntent()</p>
<ol start="2">
<li><p>得到acitivity的 source和result 也就是从哪里来,结束后返回到那里</p>
</li>
<li><p>创建activityRecord. </p>
</li>
</ol>
<p>他在AMS里代表一个activity的记录.每次启动一个activity就会生成一个ActivityRecord. ActivityRecord有个token变量.这个token会传给WMS.这样一个activity在AMS.WMS里就连在一起了.</p>
<ol start="4">
<li><p>处理activityRecord 的launchMode和flag.</p>
</li>
<li><p>通过WMS.addAppToken.把AMS里这个ActivityRecord的appToken关联到WMS里的WindowToken.这样activity.AMS.WMS.里就都可以通过这个token来识别对方.也就都能定位到这个activity了.这个apptoken会随着activity的启动.由AMS在发给Activity</p>
</li>
<li><p>为ActivityRecord 创建一个新的TaskRecord. 每个ActivityRecord都会属于一个TaskRecord.表示他所属的任务栈.</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr628nfrtj319u0t6422.jpg" alt="image-20200311220332590"></p>
<ol start="6">
<li><p>找到栈顶正在运行的ActivityRecord. 暂停他.好为我们启动新的avtivity腾出空间.</p>
<p> ActivityRecord next = <strong>topRunningActivityLocked</strong>(null);</p>
<p>   <strong>startPausingLocked</strong>(userLeaving, false); 这里会调用要pause的那个ActivityRecord对应的thread.来执行pause,这里的thread是ApplicationThread. 是APP进程传递给AMS的binder.用于AMS向APP发信息.</p>
</li>
<li><p>AMS 和ApplicationThrad通过binder通信.把消息带给旧activity进程ActivityThread. 然后执行ActivityThread.handlePauseActivity -&gt;ActivityThread.ActivityThread -&gt;AMS.activityPaused,这里回调AMS表示pause完成.然后AMS继续执行新activity的启动.</p>
</li>
<li><p>WMS 隐藏前一个activity的窗口</p>
</li>
</ol>
<p>mService.mWindowManager.setAppVisibility(prev.appToken, false);</p>
<ol start="9">
<li>旧activity执行pause后.新activity的 ProcessRecord还始终是空, 这时会为他创建ProcessRecord,这时通过activity所在的APP的包名和他的uid创建.</li>
</ol>
<p>​    ProcessRecord app = mService.<strong>getProcessRecordLocked</strong>(r.processName, r.info.applicationInfo.uid);</p>
<p>  mService.<strong>startProcessLocked</strong>(r.processName, r.info.applicationInfo, true, 0,</p>
<p>​                “activity”, r.intent.<strong>getComponent</strong>(), false, false);</p>
<ol start="10">
<li>然后通过AMS.启动ActivityThread线程.这时通过socket想Zygote进行发消息.然后zygote进程fork出来的app进程.然后执行ActivityThread.main函数</li>
</ol>
<p>Process.ProcessStartResult startResult = Process.<strong>start</strong>(“android.app.ActivityThread”,</p>
<p>​                    app.processName, uid, uid, gids, debugFlags, mountExternal,</p>
<p>​                    app.info.targetSdkVersion, null, null);</p>
<p>11.ActivityThread就是APP的住线程.他初始化了Lopper.并向AMS执行AttachApplication方法表示自己启动成功.</p>
<p>12.AMS接受 ActivityThread的信息后.包装这个进程对应的ProcessRecord.此时Activity对应的进程已经启动.要开始启动Activity了. AMS找到顶端要启动的activity.命令APP进程开始启动</p>
<p>app.thread.<strong>scheduleLaunchActivity</strong>(new <strong>Intent</strong>(r.intent), r.appToken,</p>
<p>​                    System.<strong>identityHashCode</strong>(r), r.info,</p>
<p>​                    new <strong>Configuration</strong>(mService.mConfiguration),</p>
<p>​                    r.compat, r.icicle, results, newIntents, !andResume,</p>
<p>​                    mService.<strong>isNextTransitionForward</strong>(), profileFile, profileFd,</p>
<p>​                    profileAutoStop);</p>
<ol start="13">
<li>ActivityThread开始启动activity. 先根据package信息创建Application对象.也就是androidmainfest里Application标签的信息来创建的,然后反射创建activity对象.执行activity.<strong>attach</strong>(),attach里.会为activity绑定一个phoneWindow对象,一个WindowManager对象. phoneWindow是窗口的抽象.他负责管理view树,窗口属性LayoutParams.是activity和view树的桥梁.</li>
</ol>
<p>Application app = r.packageInfo.<strong>makeApplication</strong>(false, mInstrumentation);</p>
<p>  activity.<strong>attach</strong>(appContext, this, <strong>getInstrumentation</strong>(), r.token,</p>
<p>​                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</p>
<p>​                        r.embeddedID, r.lastNonConfigurationInstances, config);</p>
<ol start="14">
<li><p>继续执行activity.onCreate,这里又会执行setContentView .而setContentView是执行的PhoneWindow的同名方法,这里会初始化view树的跟布局Docerview.并把我们的布局加入他的ziview中.这时整个控件树就完成了.这也就看到.整个空间树的根是DocerView并且由Phonewindow管理.</p>
<p> mDecor = <strong>generateDecor</strong>();</p>
<p> mLayoutInflater.<strong>inflate</strong>(layoutResID, mContentParent);</p>
</li>
<li><p>继续执行activity.onrestart. 然后在继续有AcitvityThread处理activity的resume,这里是先执行activity的onResume.然后要把activity的窗口注册到WMS中.并先隐藏窗口.等WMS窗口注册成功,再把窗口显示出来.</p>
<p>performResumeActivity,(token, clearHide);</p>
<p>View decor = r.window.getDecorView();</p>
</li>
</ol>
<p>​       decor.setVisibility(View.INVISIBLE);</p>
<p>​       ViewManager wm = a.getWindowManager();</p>
<p>​       wm.addView(decor, l);</p>
<ol start="16">
<li><p>这里的wm 就是之前activity执行attach时创建的WindowManager.每个activity对应一个WindowManager.不过这个WindowManager只是个代理.会把请求转发给WindowManagerGlobal.这是个进程唯一的管理类.而WindowManagerGlobal又创建ViewRoomImpl,这是每个view树一个的对象,有viewrootimpl来addView.</p>
<p> root = new <strong>ViewRootImpl</strong>(view.<strong>getContext</strong>(), display);</p>
<p>root.<strong>setView</strong>(view, wparams, panelParentView);</p>
</li>
<li><p>viewrootimpl里 ,通过IWindowSession调用WMS来添加窗口,获得surface,同时进行第一次视图绘制.</p>
</li>
</ol>
<p>mWindowSession.addToDisplaymWindow, mSeq, mWindowAttributes,</p>
<p>​                            <strong>getHostVisibility</strong>(), mDisplay.<strong>getDisplayId</strong>(),</p>
<p>​                            mAttachInfo.mContentInsets, mInputChannel)</p>
<p>18.第一次绘制只会协商窗口的尺寸和view树期望的尺寸. 这里又调用mWindowSession.relayout来同WM协商窗口的宽高.同时WMS会生成surface返回给APP.此后app的绘制都是在这个canvas的画板上.</p>
<p>int relayoutResult = mWindowSession.<strong>relayout</strong>(</p>
<p>​                mWindow, mSeq, params,</p>
<p>​                (int) (mView.<strong>getMeasuredWidth</strong>() * appScale + 0.5f),</p>
<p>​                (int) (mView.<strong>getMeasuredHeight</strong>() * appScale + 0.5f),</p>
<p>​                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,</p>
<p>​                mWinFrame, mPendingContentInsets, mPendingVisibleInsets,</p>
<p>​                mPendingConfiguration, mSurface);</p>
<ol start="19">
<li><p>之后viewrootImpl 通过performMeasure 调用view.measure 又遍历调用view.onMeasure进行控件树的测量</p>
<p>viewrootimpl在通过performLayout调用view.layout又遍历调用view.onLayout 进行控件树的布局</p>
<p>viewrootimpl在通过performDraw调用view.draw又遍历调用view.onDraw 进行控件树的布局</p>
<p>这里.控件树的绘制就都完成了. 此时activity已经正确显示出来.</p>
</li>
</ol>
<pre><code>这里再列出出现的一些对象

ProcessRecord. AMS里对APP进程的抽象对象.代表一个进程

TaskRecord   AMS里对APP启动栈的抽象.这个和启动模式相关.如singleTop.singleInstance

ActivityRecord  AMS里对APP启动一个Activity的抽象.一个Activity在如果在栈中有多个对象,就有多个ACtivityRecord

ACtivityStack. AMS里操作APP启动的类. AMS把启动的很多功能都交给他来完成

ActivityRecord.appToken.   这个token是联系一个activity在AMS和WMS里的指令令牌.由AMS创建.WMS会把这个令牌和一个WindowToken进行匹配. 从而表示一个activity

ApplicationThread. 这是一个binder.提供给AMS 的 属于app进程.AMS通过他来调用App进程

ActivityThread APP的主线程. ApplicationThread就是属于ActivityThread的.ApplicationThread接到消息后发送到ActivityThread的小弟队列中.等待ActivityThread处理.

AppWindowToken  是WindowToken的子类.用来标识一个activity在WMS端的记录.一个启动了的activity对应一个AppwindowToken. 

WindowState 是WMS用来标识一个窗口.每个WindowState 有一个W的binder. 这个W是iWindow类.是APP进程提供给WMS的回调binder. 每个WindowState 标识一个窗口.而一个activity可能有多个窗口,因此,就是一个activity在WMS里对应多个WindowState.也对应多个IWindow的回调. 但是他们通过同一个WindowToken来对应APP端的一个activity.

PhoneWindow.每个activity里一个.标识一个窗口,他持有窗口的属性layoutparams.控件树,和控件触摸事件的回调.是Activity和控件树的中间管理.

Viewrootimpl. 每个控件树的管理者.每个控件树有一个. 真正和WMS的交互是通过Viewrootimpl.他同时负责绘制流程的传递. 触摸事件的传递.activity的默认控件树是DocerView. ViewRootImpl里有内部类IWindow,也就是他接受WMS的回调. Viewrootimpl接受触摸实际发生后.会传给控件树. 对应activity则是docerview,而Docerview会先把时间传递给对应的activity.如果activity不处理,在传递给控件树,如果控件树还不处理.最后还是返回给activity.

IWindowSession. 这是APP端和WMS通信的binder. 每个进程唯一.

WindowManager.每个activity一个.用来管理窗口的添加更新等.他只是一个代理.把事件会传递给WindowManagerGlobal

WindowManagerGlobal .每个进程一个. 负责管理该进程所有窗口的添加等.ViewRootImpl就是由他为每个view控件树创建的</code></pre><p>最后附一张总图</p>
<p> <img src="https://tva1.sinaimg.cn/large/00831rSTly1gcr629mwh0j31920u0dq2.jpg" alt="activityqwerqwe"></p>

        
      </div>
      
      
      
    </div>
    

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liujiakuo</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#WMS"><span class="nav-text">WMS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WMS-启动"><span class="nav-text">WMS 启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SystemServer-run"><span class="nav-text">SystemServer.run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WMS-main"><span class="nav-text">WMS.main</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WMS的重要成员"><span class="nav-text">WMS的重要成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InputManagerService-mInputManager"><span class="nav-text">InputManagerService mInputManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Choreographer-mChoreographer"><span class="nav-text">Choreographer mChoreographer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WindowAnimator-mAnimator"><span class="nav-text">WindowAnimator mAnimator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WindowManagerPolicy-mPolicy"><span class="nav-text">WindowManagerPolicy mPolicy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SparseArray-mDisplayContents"><span class="nav-text">SparseArray mDisplayContents</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-lt-IApplicationToken-WindowToken-gt-mTokenMap"><span class="nav-text">HashMap&lt;IApplicationToken, WindowToken&gt; mTokenMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-lt-AppWindowToken-gt-mAppTokens"><span class="nav-text">ArrayList&lt; AppWindowToken&gt; mAppTokens</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-lt-IWIndow-WindowState-gt-mWindowMap"><span class="nav-text">HashMap&lt;IWIndow, WindowState&gt; mWindowMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet-lt-Session-gt-mSessions"><span class="nav-text">HashSet&lt; Session &gt;  mSessions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WMS窗口管理结构"><span class="nav-text">WMS窗口管理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加窗口"><span class="nav-text">添加窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解windowToken"><span class="nav-text">理解windowToken</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解WindowState"><span class="nav-text">理解WindowState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#窗口显示次序"><span class="nav-text">窗口显示次序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口的布局"><span class="nav-text">窗口的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WMS-relayoutWindow"><span class="nav-text">WMS.relayoutWindow</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安卓控件系统"><span class="nav-text">安卓控件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础类介绍"><span class="nav-text">基础类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRoot"><span class="nav-text">ViewRoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Window"><span class="nav-text">Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windowManager"><span class="nav-text">windowManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WindowManagerGlobal"><span class="nav-text">WindowManagerGlobal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口添加过程"><span class="nav-text">窗口添加过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解ViewRootImpl"><span class="nav-text">理解ViewRootImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRootImpl-创建"><span class="nav-text">ViewRootImpl 创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRootImpl-setView-注册窗口"><span class="nav-text">ViewRootImpl.setView 注册窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRootImpl-performTraversals-重绘"><span class="nav-text">ViewRootImpl.performTraversals 重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预测量"><span class="nav-text">预测量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布局窗口和最终测量"><span class="nav-text">布局窗口和最终测量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#viewRootImpl-performTraversals"><span class="nav-text">viewRootImpl.performTraversals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#viewRootImpl-performMeasure"><span class="nav-text">viewRootImpl.performMeasure</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#View-measure"><span class="nav-text">View.measure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#viewgroup-measureChildWithMargins"><span class="nav-text">viewgroup.measureChildWithMargins</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Framelayout-onMeasure"><span class="nav-text">Framelayout.onMeasure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewRootImpl-performLayout"><span class="nav-text">ViewRootImpl.performLayout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#view-layout"><span class="nav-text">view.layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinearLayout-onLayout"><span class="nav-text">LinearLayout.onLayout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewRootImpl-performDraw"><span class="nav-text">ViewRootImpl.performDraw</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控件树绘制讲解"><span class="nav-text">控件树绘制讲解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入事件派发"><span class="nav-text">输入事件派发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#触摸模式"><span class="nav-text">触摸模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#View-requestFocus"><span class="nav-text">View.requestFocus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewGroup-requestFocus"><span class="nav-text">ViewGroup.requestFocus</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件派发"><span class="nav-text">事件派发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#view-dispatchTouchEvent"><span class="nav-text">view.dispatchTouchEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ViewGroup-dispatchTouchEvent"><span class="nav-text">ViewGroup.dispatchTouchEvent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解PhoneWindow"><span class="nav-text">理解PhoneWindow</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Activity-启动整体流程"><span class="nav-text">Activity 启动整体流程</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujiakuo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
    <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>

  

</body>
</html>
