<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","width":400,"display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="1.java内存1.1内存区域划分java虚拟机会把内存分成几个不同的区域,都有各自的用途程序计数器(program counter register)pc寄存器用来指向接下来执行的字节码指令的地址,通过更新pc指令的值来连续执行指令.每个线程都有自己的pc寄存器">
<meta name="keywords" content="java虚拟机">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解java虚拟机-图传版">
<meta property="og:url" content="http://yoursite.com/2020/01/23/深入理解java虚拟机的-图床版/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.java内存1.1内存区域划分java虚拟机会把内存分成几个不同的区域,都有各自的用途程序计数器(program counter register)pc寄存器用来指向接下来执行的字节码指令的地址,通过更新pc指令的值来连续执行指令.每个线程都有自己的pc寄存器">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahryastj30ok0bcwgb.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauv04p9j30k00bi0v1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahub8qhj30ss0cwgpa.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamq1bojj30u60d678m.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauujmrsj30yi0k2gp1.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaut4xemj30uy0fsdhs.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahsfduyj30rg0fm79b.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamu5jeuj30va0g440g.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamidm1pj30w008k40s.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamo48qtj30vs0hy78i.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauu1uqlj30w60e641a.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamkdbyzj30xc0fijui.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahs3l5cj30uq04ewfk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahur4ofj30uk0iuwij.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamldkk2j30u00fmn13.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcame79itj30ri0eutbg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamson0aj30wu0lydj3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamck6myj30qk0cejst.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamrasj7j30rg0g4413.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaus996gj30ry0em0yh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauvh3b9j30sy0sc0y0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcammq5g9j30ri0hstca.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamovbfwj30sq0bgju0.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamtma3bj30ru05gwfd.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcautlhynj30ra0a2wgg.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahtwoubj30t405g3za.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamdqmmmj30re0d076z.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauwfvbpj30ro05ot9a.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamiv0afj30su0b2gn7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamn8evbj30rc04iaam.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamfnggfj30r40ni0xc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauqkpp2j30ee07gt9d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahsvj54j30ia07et9d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamjvit8j30qu0aojt7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamhkf33j30qe0jqac3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamku9igj30lq07sq3s.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaurqccbj30c60budho.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamhy2j2j30rs0n0q4u.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamen0bmj30hg072mxn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamphtm5j30o40jeta5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauw29sej30wg0cowg7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamje3kwj30lc09o75h.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamqbsq6j30rs06s3yx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamnofjoj30rc08ijsm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaurbi7aj30ts0si134.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcausrqtxj30j40zyjwa.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauqu5jrj30mc10mgsj.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamqtr3qj30m60bsmyx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamsaiznj30rw03q0tf.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamt5labj30sk0dm412.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamg2j9pj307k05ajrl.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamdcvhyj30r809yt9q.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamru55wj30km0n60zk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcammb6n9j30k20qcmyt.jpg">
<meta property="og:updated_time" content="2020-03-07T11:47:24.424Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解java虚拟机-图传版">
<meta name="twitter:description" content="1.java内存1.1内存区域划分java虚拟机会把内存分成几个不同的区域,都有各自的用途程序计数器(program counter register)pc寄存器用来指向接下来执行的字节码指令的地址,通过更新pc指令的值来连续执行指令.每个线程都有自己的pc寄存器">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahryastj30ok0bcwgb.jpg">
  <link rel="canonical" href="http://yoursite.com/2020/01/23/深入理解java虚拟机的-图床版/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>深入理解java虚拟机-图传版 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/23/深入理解java虚拟机的-图床版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujiakuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">深入理解java虚拟机-图传版

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-01-23 15:48:23" itemprop="dateCreated datePublished" datetime="2020-01-23T15:48:23+08:00">2020-01-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-07 19:47:24" itemprop="dateModified" datetime="2020-03-07T19:47:24+08:00">2020-03-07</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-java内存"><a href="#1-java内存" class="headerlink" title="1.java内存"></a>1.java内存</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahryastj30ok0bcwgb.jpg" alt="image-20200128150152686"></p><h2 id="1-1内存区域划分"><a href="#1-1内存区域划分" class="headerlink" title="1.1内存区域划分"></a>1.1内存区域划分</h2><p>java虚拟机会把内存分成几个不同的区域,都有各自的用途</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauv04p9j30k00bi0v1.jpg" alt="img"></p><h3 id="程序计数器-program-counter-register"><a href="#程序计数器-program-counter-register" class="headerlink" title="程序计数器(program counter register)"></a>程序计数器(program counter register)</h3><p>pc寄存器用来指向接下来执行的字节码指令的地址,通过更新pc指令的值来连续执行指令.每个线程都有自己的pc寄存器</p><a id="more"></a>



<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>java虚拟机栈也是线程私有的.每个方法都会形成一个栈帧.保存在虚拟机栈中.栈帧中保存局部变量表(也就是方法的形参和方法内的局部参数),操作数栈(用来执行方法内操作的操作栈),动态连接(连接到别的方法),方法出口(方法的返回路径)等.</p>
<p>每一个方法执行到完成的过程,就对应一个栈帧在虚拟机中入栈并出栈.</p>
<p>局部变量表在编译的时候就已经确定了空间.当进入一个方法是这个方法需要再栈帧中分数多大的局部变量空间是完全确定的。</p>
<h3 id="本地方法栈-nativ-method-stack"><a href="#本地方法栈-nativ-method-stack" class="headerlink" title="本地方法栈(nativ method stack)"></a>本地方法栈(nativ method stack)</h3><p>本地方法栈应该叫原生方法栈更合适，他是执行nativ方法的调用栈。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java堆是所有线程共享的一块内存区域,在虚拟机启动时创建,此类区域的目的就是存放对象,几乎所有的对象都在这里分配同时,内存回收也主要针对这里.</p>
<p> Java堆中还可以细分为新生代和老年代，同时为每个线程分配的缓冲区。<br>java堆由有线程共享。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是被所有线程共享的区域，它用来存储被虚拟机加载的类信息及常量(final),静态变量(static)和编译后的代码(code)。</p>
<p>有的虚拟机也把方法区称为内存永久代。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法缺的一部分。以保存编译器的各种字面量和符号引用和字符串。运行期间新的常量也可以进入运行时常量池. String字符串就在运行时常量池.</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时的一部分，而是额外的一部分内存，但是可以直接分配用来进行io读写。</p>
<h2 id="1-2对象的创建"><a href="#1-2对象的创建" class="headerlink" title="1.2对象的创建"></a>1.2对象的创建</h2><h3 id="加载类"><a href="#加载类" class="headerlink" title="加载类"></a>加载类</h3><p>当虚拟机遇到new指令时，先去检查这个指令的参数是否能定位到某个类。再判断这个类是否被加载，解析和初始化过。如果没有则先会加载解析这个类。在进行对象的分配。对象所需内存的大小在类加载完成后就确定了。为对象分配空间就等于在Java堆中分配一块确定大小的内存。</p>
<h3 id="分配对象内存"><a href="#分配对象内存" class="headerlink" title="分配对象内存"></a>分配对象内存</h3><p>对象分配内存，在多线程情况下可能不安全，有两种解决办法，一是对分配内存空间的动作，进行同步处理(一次只能允许一个线程操作)，另一种办法是把内存分配的动作按照线程划分在不同空间，也就是每个线程在Java堆中预先分配一小块内存称为本地线程分配缓冲(threa loacl allocation buffer,TLAB)。哪个线程分配对象就在哪个线程的TLAB中分配。当这个线程的缓存TLAB用完时，才需要同步锁定，将缓存中的内容同步到java堆中。</p>
<h3 id="初始化空间为0"><a href="#初始化空间为0" class="headerlink" title="初始化空间为0"></a>初始化空间为0</h3><p>​    内存分配完成后，虚拟机将分配的内存空间初始化为0。如果使用TLVB，在TLVB中也初始化为0。</p>
<h3 id="分配对象头"><a href="#分配对象头" class="headerlink" title="分配对象头"></a>分配对象头</h3><p>​    接下来对对象的对象头进行设置，对象头包括对象属于哪个类的实例，如何找到对象的元数据,对象的哈希码,gc分代信息等一些额外的参数。</p>
<h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>执行对想的<init>方法,按照程序员的意愿来初始化对象</init></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init方法：</span><br><span class="line">.Java文件在编译后会在字节码文件中生成init方法，该方法被称之为实例构造器。init方法是在对象实例化时执行的。该方法中的操作及其顺序为</span><br><span class="line">1.父类变量初始化  2.父类语句块  3.父类构造函数  4.子类变量初始化 5.子类语句块  6.子类构造函数</span><br></pre></td></tr></table></figure>

<h2 id="1-3对象的内存布局"><a href="#1-3对象的内存布局" class="headerlink" title="1.3对象的内存布局"></a>1.3对象的内存布局</h2><p>对象在内存中分成三个部分,对象头,实例数据,和对齐填充</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头分两部分，第1部分用于存储对象自身的运行时数据，如哈希码,gc分代年龄，锁状态，线程持有的锁等,通常是32或64位。第2部分是类型指针，用来指示该对象属于哪类.如果对象是数组，还需要记录数组长度.</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据是对象存储有效的信息，有从父类继承下来的属性和自己定义的属性。(代码并不在内存中对象的区域,而在上节的方法区)</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对其填充是为了让虚拟机对内存地址的操作是8字节的整倍数,提高执行的速度。但这个并不强制。</p>
<h2 id="1-4对象的访问"><a href="#1-4对象的访问" class="headerlink" title="1.4对象的访问"></a>1.4对象的访问</h2><p>通过栈上的reference引用，可以指向并操作堆上的对象。这里有两种方式,。</p>
<h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><p>reference引用指向句柄，句柄指向对象。需要在内存中划出一块作为句柄池.(句柄其实就是一个指针.)这种方式类似于间接引用,好处就是栈上的reference引用，不必直接操作内存地址。这样在堆中的对象进行内存回收而导致地址移动后,只需要更新句柄,不需要更新栈上的reference引用.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahub8qhj30ss0cwgpa.jpg" alt="image-20200124100422538"></p>
<h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><p>指针则是reference引用直接指向对象的地址。这是一种强绑定的关系.好处是节省内存.且因为是直接访问,速度快.坏处是gc后对象地址发生变化,则也需要变更账上的reference引用.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamq1bojj30u60d678m.jpg" alt="image-20200124102023409"></p>
<h1 id="2-垃圾收集与内存回收"><a href="#2-垃圾收集与内存回收" class="headerlink" title="2.垃圾收集与内存回收"></a>2.垃圾收集与内存回收</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauujmrsj30yi0k2gp1.jpg" alt="image-20200128150214852"></p>
<p>通常,垃圾收集都是针对堆上内存来说的.栈的内存会随着方法的进入退出进行分配和和释放,方法的栈帧，在类加载时就已确定大小。而在堆中。不同对象的需要内存可能不一样，需要在运行期间才能分配，因此堆上的内存分配和回收都是动态的。垃圾收集器主要关注这部分内存。</p>
<h2 id="2-1判断对象死亡"><a href="#2-1判断对象死亡" class="headerlink" title="2.1判断对象死亡"></a>2.1判断对象死亡</h2><h3 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h3><p>给对象添加一个引用计数器，每一个地方引用它时计数器就加一,当引用失效时计数器就减1，任何时刻计数器为0就表示对象没有被使用。这种方法实现简单，但是缺点却没法解决两个或多个对象互相引用,因此造成死循环的问题。主流的虚拟机都没采用这种办法。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>选择一系列成为gc roots的对象作为起始节点，开始向下遍历。所有遍历到的对象构成引用链,引用链上的对象说明可达。不在引用链上的对象说明不可达，证明此对象不可用。</p>
<p>有下列对象可以作为gc roots对象。</p>
<p>虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法(native方法)中引用的对象。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>强应用就是指程序代码中普遍存在的类似A a=new A()，垃圾回收不会收集强引用的对象。<br>软应用会在。发生内存溢出之前，gc对这些对象进行回收，如果回收后还没有足够的内存就发生内存溢出。<br>弱用对象会在下一次gc发生时被回收。<br>虚引用对象只是用来在回收时发送一个系统通知</p>
<h3 id="对象死亡过程"><a href="#对象死亡过程" class="headerlink" title="对象死亡过程"></a>对象死亡过程</h3><p>就像死亡要经历两次标记过程。对象在可达性分析后发现没有与GC Roots相连的应用链，就会被第1次标记,如果需要执行finanlize方法就去执行它。在finanlize方法中，如果能与gc roots 引用链进行标记，那么该对象不会被回收。如果该对象不需要执行finanlize方法就会被第2次标记,如果此时还没有与gc roots引用链进行链接。接下来的这次gc就会把它回收。</p>
<p>finanlize方法一定会被执行，且只会执行一次.但不保证一定能执行完，如果该方法中有耗时的操作，可能会并不执行完成。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的回收效率通常很低，一般可以回收的是常量和无用的类.<br>对于常量没有任何的对象引用它时，就会被回收。比如一个字符串”abc”,当没有任何String的对象指向他时，他会在必要时被回收。<br>对于类，则需要该类的所有实例被回收,加载该类的class loader已经被回收。该类对应的class对象没有被引用,无法通过反射来调用该类的方法</p>
<h2 id="2-2垃圾收集算法"><a href="#2-2垃圾收集算法" class="headerlink" title="2.2垃圾收集算法"></a>2.2垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记清楚算法简单并且快速，标记所有需要回收的内存。标记完后统一回收被标记的对象。这种方法会产生大量不连续的内存碎片。有可能一次回收后并没有产生所需要的内存因而会再次进行垃圾收集.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaut4xemj30uy0fsdhs.jpg" alt="image-20200124111114616"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法将内存分为两半。每次只使用其中的一半内存。当这一块内存使用满了。把这块内存中所有不需要回收的对象移动到另一块。再把原来那块内存清除掉。这种算法不会产生内存碎片。代价是内存缩小为原来一半。</p>
<p>现在的虚拟机采用1:1:8的方式分配内存。一块大的eden空间和两个小的survivor空间.每次使用eden空间和一个survivor空间。内存满时把这两块空间中存活的对象，移动到另一个survivor空间。清空原来的agent和survivor空间.这样空间利用率就达到了1:9。survivor只能保留10%的内存。如果存活对象超过这个内存。就需要去把对象分配在老年代。这叫内存分配担保.</p>
<p>复制算法适合对象存活率较低的方式。而如果对象存活率较高，就需要进行内存分配担保</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahsfduyj30rg0fm79b.jpg" alt="image-20200124111831995"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法适合内存对象。存活率较高的区域。因此一般用于老年代.标记整理算法也称标记压缩。首先标记出需要存活的对象。然后把这些对象压缩到内存的一端。清理边界以外的内存。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamu5jeuj30va0g440g.jpg" alt="image-20200124112345766"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamidm1pj30w008k40s.jpg" alt="image-20200124112448008"></p>
<h2 id="2-3hotSpot虚拟机实现gc"><a href="#2-3hotSpot虚拟机实现gc" class="headerlink" title="2.3hotSpot虚拟机实现gc"></a>2.3hotSpot虚拟机实现gc</h2><h3 id="提前记录对象地址"><a href="#提前记录对象地址" class="headerlink" title="提前记录对象地址"></a>提前记录对象地址</h3><p>虚拟机会在类加载完成时，知道这个类数据中哪些地方存在的对象的引用,通过一个数据结构就是提前记录对象的位置。而不需要在运行时遍历整个内存来得知对象的位置。</p>
<h3 id="线程进入安全点-安全区等待gc"><a href="#线程进入安全点-安全区等待gc" class="headerlink" title="线程进入安全点/安全区等待gc"></a>线程进入安全点/安全区等待gc</h3><p>建立安全点和安全区，也就是在安全点和安全区中(运行中的线程进入安全点,被挂起的线程进入安全区)，对象的引用数据进行更新。而在执行gc时，所有的线程也要呆在安全点和安全区中，保证此时引用，关系不发生变化。因为如果一边gc一边对象的引用发生变化，就会发生数据错乱.也就是常说的stop word,GC操作时候所有线程停止运行.停在安全点内部。</p>
<h3 id="执行gc过程"><a href="#执行gc过程" class="headerlink" title="执行gc过程"></a>执行gc过程</h3><p>Gc通常是单线程执行。在它执行时所有线程都停止，它执行完成后，其他线程再继续恢复工作。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保简单说就是新生代分配内存不足时,把对象直接分配到老年代.但是这需要老年代有足够的内存才行.不然空间分配在老年代就会失败.</p>
<h2 id="2-4各种收集器简介"><a href="#2-4各种收集器简介" class="headerlink" title="2.4各种收集器简介"></a>2.4各种收集器简介</h2><p>这里就了解下吧</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamo48qtj30vs0hy78i.jpg" alt="image-20200125101403537"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauu1uqlj30w60e641a.jpg" alt="image-20200125101443975"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamkdbyzj30xc0fijui.jpg" alt="image-20200125111459378"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahs3l5cj30uq04ewfk.jpg" alt="image-20200125111537836"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahur4ofj30uk0iuwij.jpg" alt="image-20200125111554256"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamldkk2j30u00fmn13.jpg" alt="image-20200125111623164"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcame79itj30ri0eutbg.jpg" alt="image-20200125111632397"></p>
<h1 id="3-类文件结构"><a href="#3-类文件结构" class="headerlink" title="3.类文件结构"></a>3.类文件结构</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamson0aj30wu0lydj3.jpg" alt="image-20200128150233447"></p>
<p>.class文件是虚拟机能解释执行的输入文件. java虚拟机目前已经不是与java掌握语言进行绑定的，所有的语言，如果能够转化成class文件，都可以被Java虚拟机解释执行。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamck6myj30qk0cejst.jpg" alt="image-20200125113042760"></p>
<h2 id="3-1class文件结构"><a href="#3-1class文件结构" class="headerlink" title="3.1class文件结构"></a>3.1class文件结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流,各个数据项目按严格的顺序连续排在一起，中间没有添加任何分隔符,因此每部分数据都会指出它的大小。class文件格式是类似C语言的结构体.有两种数据类型,无符号数和表.</p>
<p>u1,u2,u4,u8代表1.2.4.8子节的无符号数.无符号数用来表示数字,引用,数值或字符串值.</p>
<p>表由多个无符号数和其他表构成</p>
<p>整个class文件就是一张表.如下,</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamrasj7j30rg0g4413.jpg" alt="image-20200125124359609"></p>
<p>我们要知道，一个java类就构成一个class文件.内部类会存在于额外的class文件中.当描述一个数据，但数量不确定时，会使用一个前置的计数器加连续的数据项构成。例如 interfs_count和interfas. 前边先指明数据的个数.后边连续跟着interfs_count个interfaces类型的数据.因为class文件没有分隔符号，所以数据的存储顺序,大小都是严格限定的。并且class文件是大端法(big-edndian)也就是高位在前.地位在后。</p>
<h3 id="magic-模数和版本"><a href="#magic-模数和版本" class="headerlink" title="magic 模数和版本"></a>magic 模数和版本</h3><p>模数.4个字节,用来标识文件格式,确定这个文件是否能被虚拟机接受。java文件默认为cafebaby.其实类似于拓展名，只是拓展名可以变更模数不能变更。</p>
<p>minor_version 2个字节,表示次版本号. major_version主版本号.高版本可以向前兼容.虚拟机也向前兼容.</p>
<h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>constant_pool_count  2字节.指明常量池个数</p>
<p>constant_pool  连续的常量池.</p>
<p>常量池中存放字面量和符号引用(符号引用就是用符号来指代各种对象和属性).其中每一项都一个表.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字面量是指由字母，数字等构成的字符串或者数值，字面量可以理解为初始值,它只能作为右值出现(等号右边)</span><br><span class="line">var a = 123 //123是字面量</span><br><span class="line">var b = &apos;test&apos; //&apos;test&apos;是字面量</span><br><span class="line">var arr = [4,6,78] //[4,6,78]是字面量</span><br><span class="line">var obj = &#123;a:&apos;11&apos;,b:&apos;222&apos;&#125; //&#123;a:&apos;11&apos;,b:&apos;222&apos;&#125;是字面量</span><br><span class="line">符号引用包括三方面</span><br><span class="line">类的接口和全限定名 (全限定名就是 com/lang/Object/String 这种包含了类名和包名,可以定位到唯一的类)</span><br><span class="line">字段的名称和描述符</span><br><span class="line">方法的名称和描述符</span><br></pre></td></tr></table></figure>

<p>常量池中有14中常量类型.每个类型都通过第一个u1标志位tag来标识该常量是哪个类型.然后在接该类型的数据.</p>
<p>所有类型汇总如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaus996gj30ry0em0yh.jpg" alt="image-20200125131740077"></p>
<p>不同的常量类型具有不同的常量结构，把结构汇总如下。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauvh3b9j30sy0sc0y0.jpg" alt="image-20200125131800618"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcammq5g9j30ri0hstca.jpg" alt="image-20200125131920661"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个常量池数据为开始为 0700 0201 001d   通过查表6.3.发现07是u1代表class类型常量.总共3个自己长度, 那么该常量就是 0700 02 共3个字节,后边的01 001d 是下一个常量的数据.  0002是u2表示执行权限的名常量项的索引.</span><br></pre></td></tr></table></figure>

<h3 id="访问标识-asses-flags"><a href="#访问标识-asses-flags" class="headerlink" title="访问标识 asses_flags"></a>访问标识 asses_flags</h3><p>他们标识用于识别类或接口层次的访问信息，包括类还是接口等.采用了位模式.如下,这是用来修饰这个class文件对应的类的.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamovbfwj30sq0bgju0.jpg" alt="image-20200125172121338"></p>
<h3 id="类索引this-class-父类索引super-class-接口索引interface"><a href="#类索引this-class-父类索引super-class-接口索引interface" class="headerlink" title="类索引this_class . 父类索引super_class . 接口索引interface"></a>类索引this_class . 父类索引super_class . 接口索引interface</h3><p>类和父类都是u2类型.2个字节.因为只有一个.而接口索引可能是多个.因为java是单继承多实现</p>
<p>类索引用于确定之类的全限定名，索引用于确定这个父类的全限定名，接口索引用于确定接口的全限定名.他们都是索引,指向常量池中类型为CONSTAT_Class_info类型的常量池.(也就是说这三个索引的值都在常量池中,这里保存值在常量池中的索引.而对应的类型是常量池中CONSTAT_Class_info结构对应6-3图的类型7)。</p>
<p>全限定名就是包名加类名的结构.用来唯一确定该类.    java/lang/object  表示object类</p>
<h3 id="字段表-fields"><a href="#字段表-fields" class="headerlink" title="字段表 fields"></a>字段表 fields</h3><p>字段表由 fields_count 表示数目,然后跟这 这个数目的fields结构组成</p>
<p>字段包括类变量和对象变量. 字段有如下属性,可见性(public,private,protected),类变量还是对象变量(static),是否可变(final),并发可见性(volatile),是否序列化(transient)及字段的类型(基本类型还是类类型)和字段的名称</p>
<p>字段表结构如下,field_info</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamtma3bj30ru05gwfd.jpg" alt="image-20200125175441131"></p>
<p>第一个字段访问表示acces_flags是另一个表的索引.结构如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcautlhynj30ra0a2wgg.jpg" alt="image-20200125175600525"></p>
<p>这里有些访问表示可以组合,有些不可以.其实很好理解 </p>
<p>name_index 和descriptor_index    是索引值表示字段的简单名称和字段和方法的描述符,用来唯一标识这个字段.class文件中不会列出父类的字段.父类的字段在他自己的class文件中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static final  int a= 10;</span><br><span class="line">a就是简单名称.  int 是字段描述符(public static String Synchronize 在访问标识中已经注明了),而且字段的描述符和方法的描述符比较类似.因此是同一个结构但内容不同.</span><br><span class="line"></span><br><span class="line">描述方法则是名称和方法描述符  </span><br><span class="line">public static String   add(int a, int b) &#123;&#125;</span><br><span class="line">add 就是方法的简单名称,  String  int int  方法的返回值,修饰符,形参构成了方法的描述符.</span><br></pre></td></tr></table></figure>

<p>因此一个字段表格描述了一个属性的全部内容.</p>
<p>attribute 用来描述一些额外的 属性.可有可无. 比如 fina String= ‘abc’  这个abc的初始值就存在这个字段的属性中.</p>
<h3 id="方法表-mothods"><a href="#方法表-mothods" class="headerlink" title="方法表 mothods"></a>方法表 mothods</h3><p>方法表用来标识一个方法. 通过 访问标志(access_flags),名称索引(name_index),描述符索引(descriptor_index),属性表(attributes),和字段表类似.只是具体数据有些不同</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahtwoubj30t405g3za.jpg" alt="image-20200125183624212"></p>
<p>访问表示 access_flags和字段表不太一样如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamdqmmmj30re0d076z.jpg" alt="image-20200125202042154"></p>
<p>名称索引name_index 指向常量池中符号引用.</p>
<p>描述符 descriptor_index也指向常量池中. 通过名称和描述符来表示唯一的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">描述方法则是名称和方法描述符  </span><br><span class="line">public static String   add(int a, int b) &#123;&#125;</span><br><span class="line">add 就是方法的简单名称,  String  int int  方法的返回值,修饰符,形参构成了方法的描述符.</span><br></pre></td></tr></table></figure>

<p>属性 attribute 和字段表的类似.方法中的代码.转化为字节码指令后.就保存在code属性中.</p>
<p>java中通过方法名,形参来确认一个方法的唯一性.class文件还可以通过返回值不同来区分方法.</p>
<h3 id="属性表-attribute"><a href="#属性表-attribute" class="headerlink" title="属性表 attribute"></a>属性表 attribute</h3><p>因为字段表和方法表都有属性这一项目.因此把他抽象统一出来.单独做成一个表.</p>
<p>属性表因为用于不同的地方.因此具有很多格式.但是同一抽象为三部分,属性名称索引,属性长度.属性信息</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauwfvbpj30ro05ot9a.jpg" alt="image-20200125210920919"></p>
<p>属性名称索引 attribute_name_index 指向常量池中的名称</p>
<p>属性长度 attribute_length 支出最后的属性信息info字段的长度.</p>
<p>info 不同的属性种类有不同的结构.但是长度已经指定了.</p>
<p>下边简介几个属性</p>
<h4 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h4><p>code属性是字节码指令的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamiv0afj30su0b2gn7.jpg" alt="image-20200125211127346"></p>
<p>max_stack 代表了操作数栈的最大深度(操作数栈属于线程私有的.位于内存的虚拟机栈中),操作数栈就是方法的指令码执行时需要使用的栈.</p>
<p>max_locals 代表局部变量所需的存储空间(局部变量也在内存的虚拟机栈中). 因此方法在执行前就已经知道局部变量的全部大小了.(局部变量包括方法的形参,方法内的局部变量.和方法内的异常参数)</p>
<p>code 代表字节码指令.并且已经指明了长度.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个code属性如下</span><br><span class="line">0009 0000002F 0001 0001 00000005 2AB7000AB1 </span><br><span class="line">u2   u4				u2	 u2   u4       5个u1</span><br><span class="line">code	长度47	max_stack=1 max_locals=1	code_length =5. 2AB7000AB1是字节码指令.</span><br></pre></td></tr></table></figure>

<p>这里注意,对于实力方法.就算方法是无参数的.如 void int() 也还是max_locals=1,因为有个隐含的this参数.指向这个方法所属的对象.这是编译器为我们自动加上的.编译器把对this关键字的访问转换为一个隐含的this参数传入方法.</p>
<p>exception_table是异常表.指示该方法内的异常处理,可有可无,结构如下.意思是.从方法的字节码指令的start_pc行到end_pc出如果出现了catch_type类的异常,跳到handle_pc行进行处理.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamn8evbj30rc04iaam.jpg" alt="image-20200125213752036"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">异常表如下</span><br><span class="line">from 		to		target		table</span><br><span class="line">0				5 		10				java/lang/Exception  	/0到5行.发生Exception异常,跳到 10行处理</span><br><span class="line">0				5			21				any 									/0到5行.发生任何异常,跳到 21行处理 也就是Exception以外的其他异常</span><br><span class="line">any 通常是finally块的处理逻辑</span><br></pre></td></tr></table></figure>

<p>注意,这个是方法内处理的try/catch异常.方法抛出的异常则是另一个属性表结构.</p>
<h4 id="innerClasses属性"><a href="#innerClasses属性" class="headerlink" title="innerClasses属性"></a>innerClasses属性</h4><p>记录内部类与外部类的关联关系的表.因为内部类是独立的class文件.需要与外部类记录关系</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamfnggfj30r40ni0xc.jpg" alt="image-20200125214840330"></p>
<p>内部类的访问标志就是指明内部类是public|private|protected 和是否有 final static abctract等修饰符,和内部类是接口还是注解还是枚举.</p>
<p>其实到这里我们就发现了.所有后是inde的都是表示对常量池中的引用.</p>
<p>最后总结,我们的java类中,所有的结构有 .类名.父类.接口.内部类.静态函数.静态块,对象函数.对象属性等.class结构就是把这些数据一一的抽象出来形成一个一个的结构体.其中所有的字面量和符号都在常量池中.其他的部分都有指向常量池的引用.然后每个结构不定长的数据都会提前指示出数据的个数.由此形成一个完整的结构体.</p>
<p>一些额外的信息</p>
<p>对于静态变量.final修饰.如果有初始值,会有constansValue属性存储初始值.static修饰如果有初始值,会在类初始化方法<clinit>方法进行初始化,对象的变量在对象的初始化方法<init>中初始化</init></clinit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init方法：</span><br><span class="line"></span><br><span class="line">.Java文件在编译后会在字节码文件中生成init方法，该方法被称之为实例构造器。init方法是在对象实例化时执行的。该方法中的操作及其顺序为</span><br><span class="line"></span><br><span class="line">1.父类变量初始化  2.父类语句块  3.父类构造函数  4.子类变量初始化 5.子类语句块  6.子类构造函数</span><br><span class="line"></span><br><span class="line">clinit方法：</span><br><span class="line"></span><br><span class="line">.java文件在编译后会在字节码文件中生成clinit方法，该方法被称之为类构造器。该方法中的操作及其顺序为：</span><br><span class="line"></span><br><span class="line">1.父类静态变量初始化 2.父类静态语句块 3.子类静态变量初始化 4.子类静态语句块   （若父类为接口，则不会调用父类的clinit方法，一个类可以没有clinit方法）</span><br><span class="line"></span><br><span class="line">clinit一定比init先执行，因为clinit是在类加载过程中执行的，而init是在对象实例化时执行的。整个执行顺序为：</span><br><span class="line"></span><br><span class="line">1.父类静态变量初始化  2.父类静态语句块  3.子类静态变量初始化  4.子类静态语句块   5.父类变量初始化  6.父类语句块  7.父类构造函数  8.子类变量初始化 9.子类语句块  10.子类构造函数</span><br></pre></td></tr></table></figure>

<h2 id="3-2字节码指令简介"><a href="#3-2字节码指令简介" class="headerlink" title="3.2字节码指令简介"></a>3.2字节码指令简介</h2><p>字节码指令的特点就是针对不同的数据类型有对应的指令.比如对应int数据.指令通常有个i.对于double指令通常有个d.因此把指令归类后.可以判断出数据类型.且并不是每个指令都对应全部的数据类型.</p>
<p>java虚拟机采用栈的方式来执行指令.因此都是把两个操作数读入操作数栈.在执行额外的操作指令.(操作数栈在虚拟机栈中的每个栈帧上.)</p>
<h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>用于把数据在栈帧的局部变量表和操作数栈上来回传输. 要记住.所有指令的操作都有在操作数栈上执行.因此需要把数据先读到操作数栈上.执行完在返回局部变量表上.</p>
<p>load     把一个局部变量加载到操作数栈上,如 iload(操作int数据), fload(操作float数据)</p>
<p>store    把一个数值从操作数栈上保存会局部变量表中, istore(操作int数据), fstore(操作float数据)</p>
<p>push    把一个常量加载到操作数栈上 ,也有 i.f.d等对应的指令.以后省略不写了</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>对操作数上两个值进行某种特定运算.并把结果重新保存在操作数栈顶.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauqkpp2j30ee07gt9d.jpg" alt="image-20200125224035849"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcahsvj54j30ia07et9d.jpg" alt="image-20200125224046051"></p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>把数据在不同的格式中转换.通常是小内存转为大内存如int转为float .反向转换可能导致数据精度丢失或结果出问题.</p>
<p>i2b  int to byte.    i2l int to long    . i2d  int to double</p>
<h3 id="对象创建与访问"><a href="#对象创建与访问" class="headerlink" title="对象创建与访问"></a>对象创建与访问</h3><p>new 创建对象 newarray 创建数组</p>
<p>getfield putfield     getstatic putstatic  访问类和对象的字段</p>
<p>aload    把一个数组元素加载到操作数栈</p>
<p>astore     把一个元素从操作数栈保存回数组</p>
<p>instanceof    检查对象类型        </p>
<h3 id="操作数栈管理"><a href="#操作数栈管理" class="headerlink" title="操作数栈管理"></a>操作数栈管理</h3><p>pop      弹出栈顶元素    pop2弹出栈顶2个元素</p>
<p>dup    复制栈顶元素,重新压入栈    dup2    复制栈顶2个元素,重新压入栈</p>
<p>swap    栈顶两个元素互换</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>ifeq    iflt    ifne    条件分支,如果满足条件就跳转,if是跳转分支. eq .lt ne 是满足的条件.很简单.是英文缩写 eq=equal    lt=letter than    ne=not equal</p>
<p>tableswitch     复合条件分支.    就是switch语句. 后跟几个条件</p>
<p>goto    jsr    无条件分支,执行到这里就肯定会跳转.</p>
<p>控制转移指令通常前边跟一个判断指令.判断指令会把结果压入栈顶.条件指令就是用这个结果来做条件判断跳转</p>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamjvit8j30qu0aojt7.jpg" alt="image-20200125225323566"></p>
<p>invokedynamic 指令比较特殊.他执行的方法是在运行时动态解析出来了.因为java有重写和重载的特点.有些方法在运势时才知道具体的对象是哪个.要执行的是父类的方法还是子类重写的方法还是重载的方法.因此通过这个指令实现动态执行.</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>同步指令用于多线程.可以保证一段指令只能同时有由一个线程来执行.对应的就是synchronize修饰的方法和代码块. 指令中有 monitorenter 和monitorexit. 在进入和离开时进行同步保证唯一线程执行.</p>
<p>总结下.这里的指令和计算机的汇编指令其实比较类似.只不过这里是针对栈的.因此需要有很多出入栈的指令.同时执行方法也有了额外的指令.其实相对来说更加简单 了.</p>
<h1 id="4-类加载机制"><a href="#4-类加载机制" class="headerlink" title="4.类加载机制"></a>4.类加载机制</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamhkf33j30qe0jqac3.jpg" alt="image-20200128150247956"></p>
<p>java语言里.类的加载.连接和初始化都是在程序运行期间完成.这提供了动态扩展的灵活性.也就是在运行时可以动态选择执行对象,动态选择要执行的方法.</p>
<h2 id="4-1类加载机制概括"><a href="#4-1类加载机制概括" class="headerlink" title="4.1类加载机制概括"></a>4.1类加载机制概括</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamku9igj30lq07sq3s.jpg" alt="image-20200126121651770"></p>
<p>加载.验证.准备.初始化这几个阶段的顺序是确定的.</p>
<p>每使用一个对象或者类的静态属性或方法.都需要先加载类.以下五种情况必须先对类进行初始化.而初始化之前肯定已完成类的加载.</p>
<p>1.new.getstatic.putstatic.invokstatic的字节码指令时.也就是访问类的静态变量和方法,创建对象时.</p>
<p>2.使用reflect 反射调用类时.</p>
<p>3.初始化类时,他的父类需要初始化</p>
<p>4.虚拟机启动时.需要加载带有main方法的主类,此类要初始化</p>
<p>5.jdk1.7后动态语言,使用MethodHandle时.要初始类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反射获取的信息比MethodHandle要多。</span><br><span class="line">反射是模拟java代码层面的调用，MethodHandle是模拟字节码层面的调用</span><br></pre></td></tr></table></figure>

<p>接口的初始化和类差不多.不过没有第三点,接口的初始化只有在父接口被用到的时候才初始化父接口</p>
<h2 id="4-2类加载过程"><a href="#4-2类加载过程" class="headerlink" title="4.2类加载过程"></a>4.2类加载过程</h2><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol>
<li>通过类的全限定名,找到这个类的二进制字节流(字节流可以来自文件.网络,数据库或运行时生成)</li>
<li>把这个字节流代表的静态结构转化为方法区的运行时数据结构 (数据结构保存在方法区)</li>
<li>在内存中生成代表这个类的class对象,作为方法区这个数据结构的访问入口.(这个class对象可在堆上可在方法区,看虚拟机实现.).</li>
<li>类的加载需要使用类加载器来完成.类加载器和类共同确定一个唯一的类.(同一个类由不同的加载器加载,也是两个不同的类)</li>
</ol>
<p>加载阶段与连接阶段是部分交叉进行的.加载时也会执行一些连接的任务</p>
<h3 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h3><p>验证阶段是保证类的二进制字节流是正常的,防止破坏虚拟机自身.主要分为文件格式验证,元数据验证.字节码验证.符号引用验证</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证."></a>文件格式验证.</h4><p>用来验证字节流是否符号class文件格式规范,主要是对格式的校验,保证输入的字节流能正确解析</p>
<p>模数是否正确,</p>
<p>主次版本号是否正确.</p>
<p>常量池中格式是否都支持.</p>
<p>指向常量的索引能否找到对应常量.</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>验证字节流的描述信息是否符号java语言规范</p>
<p>类是否有父类(object意外都有父类)</p>
<p>类的继承关系是否正确(不能集成被final修饰的类)</p>
<p>是否实现了父类和接口必须实现的方法</p>
<p>类的字段,方法是否和父类的产生冲突(final修饰.或者不正确的重载)</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>通过数据流和控制流分析,保证程序语义是合法的. 这阶段分析方法体.保证方法执行正常.(这个应该是编译原理相关的阶段.不是很了解这方面)</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>验证常量池中的类全限定名是否能找到对应的类</p>
<p>在指定类中通过字段表能否找到对应的属性,通过方法表能否找到对应的方法.</p>
<p>符号引用中的类,字段,方法的访问性是否合理</p>
<p>简单说就是看符号引用和真正的类,方法,字段能否对应起来.</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>这里是为类变量(static修饰)分配内存.在方法区中分配内存.并设置初始值(都初始化为0,或null,也就是把内存初始化干净).</p>
<p>如 public static int a =123;  此时会把a初始化为0  ,123的值要等类的<clinit>执行时复制</clinit></p>
<p>而 public static final int  a =123 ,则会初始化为123.因为final修饰后,123会在类的字节码文件中字段表中的constantValue 属性上出现.因此是在类文件中的.会直接初始化</p>
<p>那么 public  final int a =123呢? 这是对象的变量.会在对象初始化的时候进行初始化.</p>
<h3 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h3><p>解析阶段就是将常量池内的符号引用替换为直接引用的过程. 解析的过程可能会重复执行,但是如果之前解析成功.那么以后重复解析也会成功(invokedynamic指令是动态的,他解析可能失败)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">符号引用就是常量池内的字符串的各种组合.可以定位到某个目标,此时这个目标不一定加载到内存中.</span><br><span class="line"></span><br><span class="line">直接引用.此时目标已经加载到内存中了.直接引用可以是指针,句柄和相对偏移量.总之是可以定位到内存中该目标.</span><br></pre></td></tr></table></figure>

<p>可以理解为.class以文件形式存在时.只是通过字符可以保存目标.当等他完全加载到内存时,就需要在内存中有个直接引用.通过这个引用可以指向目标的内存地址,从而使用目标.这里的目标就是方法.属性.类,接口和对象.</p>
<h4 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a>类或接口解析</h4><p>假设当前代码在D类中,要加载C类.C类的符号引用是N,解析类有三部</p>
<p>1.如果C不是数组类,那么虚拟机把符号引用N传递给类D的类加载器.去加载类C,然后递归的加载C中依赖的其他类</p>
<p>2.如果C是数组类型,并且数组内容是对象,那么按照第一部加载C数组中的类.然后虚拟机生成这个数组</p>
<p>3.如果前两部没出异常,那么内存中就有C类的结构了.这里再验证D类是否具有C类的访问权限</p>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>解析字段需要先解析这个字段所属的类或接口,也就是字段表中class_index 中索引的类的符号引用.转为类的直接引用.假设这个类是C,要解析的字段是D</p>
<p>1.如果类C中有简单名称和字段描述符都匹配的字段.就返回这个字段</p>
<p>2.如果类C中找不到.就去他实现的接口中从下往上递归寻找字段.找到匹配的就返回</p>
<p>3.如果实现的接口也找不到.就在类C的继承的父类中找匹配的字段.返回</p>
<p>4.没找到.匹配失败,返回 java.lang.nosuchFieldError异常</p>
<p>返回这个字段后还会验证这个字段的访问权限.不匹配抛出 java.lang.ILLegalAccessError异常</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>类方法也需要先解析出该方法对应的类直接饮用.假设这个类是C,要解析的方法是D</p>
<p>1.类方法和接口方法的符号引用是分开的.如果发现不匹配.就抛出异常</p>
<p>2.在类C中查找名称和描述符都匹配D的目标,如果找到.就返回这个目标</p>
<p>3.在类C所继承的父类及以上递归查找名称和描述符都匹配D的目标,如果找到.就返回这个目标</p>
<p>4.在类C所实现的接口及以上递归中查找名称和描述符都匹配D的目标,如果找到.就返回这个目标</p>
<p>5.查找失败,返回NoSuchMothodError</p>
<p>同样,如果找到后还需要进行权限验证</p>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法和类方法类似.只是接口方法直接只查找自己和他的父接口就可以了.</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>到这里.类和接口和方法以及都加载到内存中(常量池中).并且有了直接应用指向他们.在准备阶段时,以及把类的这片内存都初始化为0或空值了.初始化阶段就是执行<clinit>方法的阶段.会把 static int a =123 ; 在代码中指定的初始赋值给字段.</clinit></p>
<p>再次重申下 <init> 和<clinit> ,一个是默认的对象的初始化,一个是默认的类的初始化</clinit></init></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">init方法：</span><br><span class="line">.Java文件在编译后会在字节码文件中生成init方法，该方法被称之为实例构造器。init方法是在对象实例化时执行的。该方法中的操作及其顺序为</span><br><span class="line">1.父类变量初始化  2.父类语句块  3.父类构造函数  4.子类变量初始化 5.子类语句块  6.子类构造函数</span><br><span class="line"></span><br><span class="line">clinit方法：</span><br><span class="line">.java文件在编译后会在字节码文件中生成clinit方法，该方法被称之为类构造器。该方法中的操作及其顺序为：</span><br><span class="line">1.父类静态变量初始化 2.父类静态语句块 3.子类静态变量初始化 4.子类静态语句块   （若父类为接口，则不会调用父类的clinit方法，一个类可以没有clinit方法）</span><br><span class="line"></span><br><span class="line">clinit一定比init先执行，因为clinit是在类加载过程中执行的，而init是在对象实例化时执行的。整个执行顺序为：</span><br><span class="line">1.父类静态变量初始化  2.父类静态语句块  3.子类静态变量初始化  4.子类静态语句块   5.父类变量初始化  6.父类语句块  7.父类构造函数  8.子类变量初始化 9.子类语句块  10.子类构造函数</span><br></pre></td></tr></table></figure>

<p>虚拟机保证<clinit> 在多线程环境中自动被加锁.同步,也就是同一时刻只有一个线程去初始化一个类.执行这个类的class方法.(因此我们可以利用这点做单例模式)</clinit></p>
<h2 id="4-3类加载器"><a href="#4-3类加载器" class="headerlink" title="4.3类加载器"></a>4.3类加载器</h2><p>类和类加载器唯一确定一个类的唯一性.每个类有独立的类命名空间,不同加载器加载同一个类,得到的就是两个不同的class对象.</p>
<h2 id="4-4双亲委派模型"><a href="#4-4双亲委派模型" class="headerlink" title="4.4双亲委派模型"></a>4.4双亲委派模型</h2><p>从java虚拟机角度看.只有两种类加载器.一种是启动类加载器,由c++语言实现,是虚拟机自身一部分,剩余类加载器归为一类.由java实现,独立于虚拟机外部.</p>
<p>启动类加载器:加载java_home\lib路径下类.用于加载系统类</p>
<p>扩展类加载器:加载java_home\lib\ext路径下类,开发者可以使用这个类加载器</p>
<p>应用程序类加载器:一般称为系统类加载器,负责加载用户路径上的类库,这个是程序中默认的加载器.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaurqccbj30c60budho.jpg" alt="image-20200127164445972"></p>
<p>双亲委派模型,简单说就是有加载类的请求后.会递归要求父类加载器来加载.如果父类加载器不加载,在让子类来加载,这就保证系统库里重要的类库都是由父类加载的,因而保证系统类在各种加载器环境中都是统一的.(因为都是由共同的父类来加载.)</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamhy2j2j30rs0n0q4u.jpg" alt="image-20200127164839718"></p>
<h1 id="5-虚拟机执行字节码"><a href="#5-虚拟机执行字节码" class="headerlink" title="5.虚拟机执行字节码"></a>5.虚拟机执行字节码</h1><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamen0bmj30hg072mxn.jpg" alt="image-20200128150259762"></p>
<h2 id="5-1运行时栈帧结构"><a href="#5-1运行时栈帧结构" class="headerlink" title="5.1运行时栈帧结构"></a>5.1运行时栈帧结构</h2><p>每个方法在运行时都会有一个栈帧结构,保存这个方法运行期间的数据.内容有局部变量表(保存局部变量和形参).操作数栈(指令执行操作使用的栈),动态连接和方法返回地址.每个栈帧分配的内存,在方法执行前就确定了.不会受到运气期间数据的影响.每个线程有自己的栈.每个方法有唯一的栈帧.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamphtm5j30o40jeta5.jpg" alt="image-20200127172319653"></p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量用于存储方法参数和方法内定义的局部变量.局部变量以变量槽(variable slot)为最小单位.每个槽可以放一个基础数据或对象引用或返回地址. 对象引用reference 可以定位到对中的这个对象和方法区中这个对象所属的类.</p>
<p> 同时.虚拟机默认会生成一个_this的局部变量给对象的方法,作为第一个形参,因此就额可以在方法中使用this指向所属的类.</p>
<p>局部变量使用前需要复制.因为虚拟机没有给局部变量进行默认赋值.</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>java虚拟机是基于栈存储执行指令的.通常他把两个数据入栈,然后执行操作时弹出这两个数据.执行完计算后在把数据保存回栈.</p>
<p>这个举例一看就懂了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin  </span><br><span class="line">iload_0    // push the int in local variable 0 onto the stack  局部变量表中0号元素入栈</span><br><span class="line">iload_1    // push the int in local variable 1 onto the stack  局部变量表中1号元素入栈</span><br><span class="line">iadd       // pop two ints, add them, push result  	弹出站内两个元素,相加,结果写回栈</span><br><span class="line">istore_2   // pop int, store into local variable 2  弹出栈中结果.保存在局部变量表中2号</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>局部变量表和栈结构变化如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauw29sej30wg0cowg7.jpg" alt="image-20200127174833771"></p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含 一个指向运行时常量池中该栈帧所属方法 引用.通过这个引用.可以在改方法中动态调用其他的方法,因为常量池中都是符号引用,可以在运行期间,由符号引用转为对象或方法的直接引用(这种方式和静态引用类似,只是是在运行时发生,称为动态引用.)</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法执行完成后,决定要跳到哪里.正常返回时可能会带值给上层调用方法者,称为正常完成出口.方法如果出错了.且异常没有包住.就异常退出了.称为异常完成出口,不会有返回值.</p>
<h2 id="5-2方法调用"><a href="#5-2方法调用" class="headerlink" title="5.2方法调用"></a>5.2方法调用</h2><p>方法调用不是方法执行.方法调用是为了确定具体要执行那个方法.因为java中有重写和重载.因此要有一个选择的过程.class文件的编译过程不包含链接过程.一切方法调用在class里都是存储的符号引用.在运行是则要动态转为内存中方法的具体地址.</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>类在由class文件加载到内存中时,也有一个符号引用转为直接引用的过程.那里是静态转换.转换的方法是在运行前就能确定方法唯一性的.而对于java的动态特性,有些符号引用转为直接引用则需要在运行期间完成.</p>
<p>静态方法(static) 和私有方法(private) 和final方法是可以静态解析的.在类加载阶段解析.虚拟机的指令中</p>
<p>invokestatic (调用静态方法)和invokespecial(调用实例构造器<init>方法,私有方法和类方法)所执行的方法可以在静态解析期间得到</init></p>
<p>invokevirtual(调用虚方法),invokeinterface(调用接口方法)和invokedynamic(调用动态方法.) 都需要在运行时动态解析出符合引用对应的直接引用.</p>
<h3 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h3><p>分派分为静态分派和动态分派.就是针对java语言的多态性.在运行期间如何找到正确的方法.</p>
<p>方法重载使用的是静态分派.发生在编译阶段.重载通过参数确定来选择哪个类型.这个看代码比较容易理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class fenpai &#123;</span><br><span class="line">    static  abstract class A &#123;&#125;</span><br><span class="line">    static class B extends A &#123;&#125;</span><br><span class="line">    static class C extends A &#123;&#125;   </span><br><span class="line">//这三个方法参数不同.因此是重载的</span><br><span class="line">    public static void sayHi(A a) &#123;</span><br><span class="line">        System.out.println(&quot;hi ,father&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHi(B b) &#123;</span><br><span class="line">        System.out.println(&quot;hi ,sister&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHi(C c) &#123;</span><br><span class="line">        System.out.println(&quot;hi ,brother&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fenpai f = new  fenpai();</span><br><span class="line">        A a1 = new B();</span><br><span class="line">        A a2 = new C();</span><br><span class="line">        f.sayHi(a1);</span><br><span class="line">        f.sayHi(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----结果----</span><br><span class="line">hi ,father</span><br><span class="line">hi ,father</span><br></pre></td></tr></table></figure>

<p>可以看到.对于  A a1 = new B();  A称为变量的静态类型. B则是变量的实际类型,那么当作为形参传递给方法时.方法使用的是 变量的静态类型.也就是认为传进来的是A类的对象.因此静态类型是编译器可以知道的.通过参数的类型A,解析到了sayHi(A a) 这个方法.</p>
<p>简单说就是重写通过形参来确定方法,而形参取决于传入参数的静态类型.</p>
<h3 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h3><p>动态分派体现在重写上(也就是子类重写父类的方法),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class fenpai &#123;</span><br><span class="line">    static  abstract class A &#123;</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            System.out.println(&quot;hi ,father&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    两个子类分别重写了父类的方法.</span><br><span class="line">    static class B extends A &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            System.out.println(&quot;hi ,brother&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class C extends A &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            System.out.println(&quot;hi ,sister&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        fenpai f = new  fenpai();</span><br><span class="line">        A a1 = new B();</span><br><span class="line">        A a2 = new C();</span><br><span class="line">        a1.sayHi();</span><br><span class="line">        a2.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----结果---</span><br><span class="line">hi ,brother</span><br><span class="line">hi ,sister</span><br></pre></td></tr></table></figure>

<p>此时的静态类型都是A,而实际类型则是B和C,那么如何执行动态分派呢?</p>
<p>在执行sayHi()时,先找到这个方法的对象的实际类型(注意这里是实际类型).也就是B,</p>
<p>如果在B中找到名称和描述符和sayHi()一样的方法.就返回这个方法的引用</p>
<p>否则,依照集成关系,从子类一次向父类遍历,找到匹配,就返回这个方法的引用</p>
<p>否则,就抛出异常</p>
<p>简单说就是重载由对象的实际类型决定,从实际类型依次向父类遍历寻找方法.</p>
<p>其实.动态分派和静态分派解决的就是在运行期间,调用哪个对象,调用该对象的哪个方法.是为了解决java语言的重写和重载问题.</p>
<h2 id="5-3字节码执行引擎"><a href="#5-3字节码执行引擎" class="headerlink" title="5.3字节码执行引擎"></a>5.3字节码执行引擎</h2><p>编译和解释的前边有一部分是一样的.如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamje3kwj30lc09o75h.jpg" alt="image-20200127220210107"></p>
<p>基于栈的指令集合基于寄存器的指令集的区别.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamqbsq6j30rs06s3yx.jpg" alt="image-20200127220304098"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamnofjoj30rc08ijsm.jpg" alt="image-20200127220314240"></p>
<p>基于栈指令的优点是可移植,忽略的硬件的具体实现,因为不同架构CPU的寄存器数目不一定一样.采用栈这种抽象结构,不管底层如何实现,指令都是一样的.缺点就是有大量的出栈入栈操作,频繁的内存方法..指令的数量多,会慢一些.</p>
<p>下边是一个栈指令集的实例讲解.很清楚了.直接抄过来.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcaurbi7aj30ts0si134.jpg" alt="image-20200127220854361"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcausrqtxj30j40zyjwa.jpg" alt="image-20200127220911497"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcauqu5jrj30mc10mgsj.jpg" alt="image-20200127220921968"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamqtr3qj30m60bsmyx.jpg" alt="image-20200127220929632"></p>
<h1 id="6-编译优化"><a href="#6-编译优化" class="headerlink" title="6.编译优化"></a>6.编译优化</h1><h2 id="早期优化"><a href="#早期优化" class="headerlink" title="早期优化"></a>早期优化</h2><p>编译过程大致分为.解析与填充符号表.注解处理器的处理注解.分析与字节码生成</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamsaiznj30rw03q0tf.jpg" alt="image-20200127225319990"></p>
<p>编译过程的主体方法如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamt5labj30sk0dm412.jpg" alt="image-20200127225339922"></p>
<h3 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h3><p>先j进行词法分析,语法分析,构成抽象语法书, 词法分析简单说就是把 int a = 2+6 转为标记(token),形成 int, a,=,2,+,6 六个标记的过程.语法分析构成抽象语法树.如下</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamg2j9pj307k05ajrl.jpg" alt="image-20200127225953369"></p>
<p>填充符号表,符号表是符号地址和符号信息的k-v的映射关系.</p>
<h3 id="注解处理器处理注解"><a href="#注解处理器处理注解" class="headerlink" title="注解处理器处理注解"></a>注解处理器处理注解</h3><p>注解是一租编译插件,可以任意处理生成的抽象语法树,进行增删改查其中的元素.如果注解处理器修改了语法书.则编译器将重新进行解析和符号填充的过程.这里循环反复直到所有的注解都处理完成.</p>
<h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成."></a>语义分析与字节码生成.</h3><p>语义分析会处理代码的逻辑结构,看代码的逻辑是否有问题,查看代码的控制流程是否正确.同时去掉代码中的语法糖.(泛型就是语法糖,他在源码中存在,编译后的字节码就已经转成原生类型了.自动拆箱装箱,foreach循环也是)</p>
<h2 id="晚期优化"><a href="#晚期优化" class="headerlink" title="晚期优化"></a>晚期优化</h2><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p>解释器比较节省内存, 如果需要程序的快速启动.解释器可以省去编译时间.提高速度.而随着代码的主机运行,编译器则发挥作用,注解把字节码转换成本地机器码.提高执行效率.通常编译器和解释器都是同时存在的.</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamdcvhyj30r809yt9q.jpg" alt="image-20200127230923840"></p>
<p>对应代码中. 被多次调用的方法. 循环体重多次执行的代码.都会转换成本地机器代码. 这叫jit即时编译.</p>
<p>这里通过一个计时器来保存确定被多次调用的方法</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcamru55wj30km0n60zk.jpg" alt="image-20200127231111318"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcammb6n9j30k20qcmyt.jpg" alt="image-20200127231145248"></p>
<p>编译的技术我不太了解.这里就不做笔记了.以后再研究了编译在做吧.</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java虚拟机/" rel="tag"># java虚拟机</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/12/30/java多线程/" rel="next" title="java多线程">
                  <i class="fa fa-chevron-left"></i> java多线程
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/01/23/深入理解java虚拟机/" rel="prev" title="深入理解java虚拟机">
                  深入理解java虚拟机 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liujiakuo</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-java内存"><span class="nav-text">1.java内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1内存区域划分"><span class="nav-text">1.1内存区域划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序计数器-program-counter-register"><span class="nav-text">程序计数器(program counter register)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java虚拟机栈"><span class="nav-text">java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈-nativ-method-stack"><span class="nav-text">本地方法栈(nativ method stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java堆"><span class="nav-text">java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时常量池"><span class="nav-text">运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接内存"><span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2对象的创建"><span class="nav-text">1.2对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载类"><span class="nav-text">加载类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配对象内存"><span class="nav-text">分配对象内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化空间为0"><span class="nav-text">初始化空间为0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配对象头"><span class="nav-text">分配对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象初始化"><span class="nav-text">对象初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3对象的内存布局"><span class="nav-text">1.3对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象头"><span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据"><span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对齐填充"><span class="nav-text">对齐填充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4对象的访问"><span class="nav-text">1.4对象的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用句柄"><span class="nav-text">使用句柄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用指针"><span class="nav-text">使用指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-垃圾收集与内存回收"><span class="nav-text">2.垃圾收集与内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1判断对象死亡"><span class="nav-text">2.1判断对象死亡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数器法"><span class="nav-text">引用计数器法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可达性分析"><span class="nav-text">可达性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用类型"><span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象死亡过程"><span class="nav-text">对象死亡过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回收方法区"><span class="nav-text">回收方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2垃圾收集算法"><span class="nav-text">2.2垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标记-清除算法"><span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制算法"><span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记整理算法"><span class="nav-text">标记整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分代收集算法"><span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3hotSpot虚拟机实现gc"><span class="nav-text">2.3hotSpot虚拟机实现gc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#提前记录对象地址"><span class="nav-text">提前记录对象地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程进入安全点-安全区等待gc"><span class="nav-text">线程进入安全点/安全区等待gc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行gc过程"><span class="nav-text">执行gc过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间分配担保"><span class="nav-text">空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4各种收集器简介"><span class="nav-text">2.4各种收集器简介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-类文件结构"><span class="nav-text">3.类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1class文件结构"><span class="nav-text">3.1class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#magic-模数和版本"><span class="nav-text">magic 模数和版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量池-constant-pool"><span class="nav-text">常量池 constant_pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问标识-asses-flags"><span class="nav-text">访问标识 asses_flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类索引this-class-父类索引super-class-接口索引interface"><span class="nav-text">类索引this_class . 父类索引super_class . 接口索引interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段表-fields"><span class="nav-text">字段表 fields</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法表-mothods"><span class="nav-text">方法表 mothods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性表-attribute"><span class="nav-text">属性表 attribute</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#code属性"><span class="nav-text">code属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innerClasses属性"><span class="nav-text">innerClasses属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2字节码指令简介"><span class="nav-text">3.2字节码指令简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载和存储指令"><span class="nav-text">加载和存储指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算指令"><span class="nav-text">运算指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换指令"><span class="nav-text">类型转换指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象创建与访问"><span class="nav-text">对象创建与访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数栈管理"><span class="nav-text">操作数栈管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制转移指令"><span class="nav-text">控制转移指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用和返回指令"><span class="nav-text">方法调用和返回指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步指令"><span class="nav-text">同步指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-类加载机制"><span class="nav-text">4.类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1类加载机制概括"><span class="nav-text">4.1类加载机制概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2类加载过程"><span class="nav-text">4.2类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加载阶段"><span class="nav-text">加载阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证阶段"><span class="nav-text">验证阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件格式验证"><span class="nav-text">文件格式验证.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据验证"><span class="nav-text">元数据验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节码验证"><span class="nav-text">字节码验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号引用验证"><span class="nav-text">符号引用验证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备阶段"><span class="nav-text">准备阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析阶段"><span class="nav-text">解析阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类或接口解析"><span class="nav-text">类或接口解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段解析"><span class="nav-text">字段解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类方法解析"><span class="nav-text">类方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口方法解析"><span class="nav-text">接口方法解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3类加载器"><span class="nav-text">4.3类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4双亲委派模型"><span class="nav-text">4.4双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-虚拟机执行字节码"><span class="nav-text">5.虚拟机执行字节码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1运行时栈帧结构"><span class="nav-text">5.1运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量表"><span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数栈"><span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态连接"><span class="nav-text">动态连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法返回地址"><span class="nav-text">方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2方法调用"><span class="nav-text">5.2方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析"><span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态分派"><span class="nav-text">静态分派</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分派"><span class="nav-text">动态分派</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3字节码执行引擎"><span class="nav-text">5.3字节码执行引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-编译优化"><span class="nav-text">6.编译优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#早期优化"><span class="nav-text">早期优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析与填充符号表"><span class="nav-text">解析与填充符号表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解处理器处理注解"><span class="nav-text">注解处理器处理注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语义分析与字节码生成"><span class="nav-text">语义分析与字节码生成.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#晚期优化"><span class="nav-text">晚期优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编译器和解释器"><span class="nav-text">编译器和解释器</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujiakuo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
