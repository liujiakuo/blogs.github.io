<!DOCTYPE html>





<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","width":400,"display":"always","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    save_scroll: false,
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="123Glide.with(this)        .load(&amp;quot;http://p3.pstatp.com/origin/pgc-image/15220293999066398493c24&amp;quot;)        .into(imageView);">
<meta name="keywords" content="android工具源码">
<meta property="og:type" content="article">
<meta property="og:title" content="glide-源码解析">
<meta property="og:url" content="http://yoursite.com/2020/03/17/glide-源码解析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="123Glide.with(this)        .load(&amp;quot;http://p3.pstatp.com/origin/pgc-image/15220293999066398493c24&amp;quot;)        .into(imageView);">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200324213130912.png">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200324223604817.png">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200324224438010.png">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200324225136996.png">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200325105633335.png">
<meta property="og:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200325111339778.png">
<meta property="og:updated_time" content="2020-03-25T05:13:55.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="glide-源码解析">
<meta name="twitter:description" content="123Glide.with(this)        .load(&amp;quot;http://p3.pstatp.com/origin/pgc-image/15220293999066398493c24&amp;quot;)        .into(imageView);">
<meta name="twitter:image" content="http://yoursite.com/2020/03/17/glide-源码解析/image-20200324213130912.png">
  <link rel="canonical" href="http://yoursite.com/2020/03/17/glide-源码解析/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>glide-源码解析 | Hexo</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <div class="container sidebar-position-left">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/glide-源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujiakuo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">glide-源码解析

            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-17 20:41:59" itemprop="dateCreated datePublished" datetime="2020-03-17T20:41:59+08:00">2020-03-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 13:13:55" itemprop="dateModified" datetime="2020-03-25T13:13:55+08:00">2020-03-25</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(this)</span><br><span class="line">        .load(&quot;http://p3.pstatp.com/origin/pgc-image/15220293999066398493c24&quot;)</span><br><span class="line">        .into(imageView);</span><br></pre></td></tr></table></figure><a id="more"></a>

<h2 id="With"><a href="#With" class="headerlink" title="With"></a>With</h2><p> 主要工作.给activity 创建了一个SupportRequestManagerFragment,这是个fragment.但是没有view显示.并且给这个fragment 绑定了一个RequestManager 和一个lifecycle. lifecycle 是用来观察fragment的生命周期的.他会回调所有注册的LifecycleListener. 而这个RequestManager也是一个LifecycleListener. 也就是说使RequestManager可以检测到声明周期的变化.</p>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>主要是创建RequestBuilder.并把url赋值给他.</p>
<h2 id="into"><a href="#into" class="headerlink" title="into"></a>into</h2><p>请求会抽象成 SingleRequest . 而目标对象抽象成target, 定义配置抽象成BaseRequestOptions.</p>
<p>Engine 是最后执行的引擎. RequestManager 负责管理发出请求.</p>
<p>获取的资源抽象为 EngineResource</p>
<p>加载任务是DecodeJob和 EngineJob</p>
<p>EngineJob 内部维护了线程池，用来管理资源加载，已经当资源加载完毕的时候通知回调。 DecodeJob 继承了 Runnable，是线程池当中的一个任务。就像上面那样，我们通过调用 engineJob.start(decodeJob) 来开始执行图片加载的任务</p>
<p>SourceGenerator是源资源生成器 .他是通过URLConnect从网络下载. 同样的还有</p>
<p>DataCacheGenerator ,从文件中读取图片资源</p>
<p>,ResourceCacheGenerator,MultiModelLoader 表示从不同的源拿到图片.</p>
<p>这里的主要逻辑是构建一个用于将数据缓存到磁盘上面的 DataCacheGenerator。DataCacheGenerator 的流程基本与 SourceGenerator 一致，也就是根据资源文件的类型找到 ModelLoader，然后使用 DataFetcher 加载缓存的资源。与之前不同的是，这次是用 DataFecher 来加载 File 类型的资源。也就是说，当我们从网络中拿到了数据之后 Glide 会先将其缓存到磁盘上面，然后再从磁盘上面读取图片并将其显示到控件上面。所以，当从网络打开了输入流之后 SourceGenerator 的任务基本结束了，而后的显示的任务都由 DataCacheGenerator 来完成。</p>
<p>Downsampler 用来解析图片.可以研究下.</p>
<p><a href="https://blog.csdn.net/qq_41979349/article/details/102627939" target="_blank" rel="noopener">https://blog.csdn.net/qq_41979349/article/details/102627939</a></p>
<p><a href="http://frodoking.github.io/2015/10/10/android-glide/" target="_blank" rel="noopener">http://frodoking.github.io/2015/10/10/android-glide/</a></p>
<h1 id="内存缓存原理"><a href="#内存缓存原理" class="headerlink" title="内存缓存原理"></a>内存缓存原理</h1><p>glide在内存中会产生两种缓存.一种是使用弱引用存储的图片缓存, 一种是lru缓存.使用时.先从弱引用中找到缓存,如果不存在.再去lru中取,然后从lru中把图片保存到弱引用中.因此,总是总弱引用中找到图片.当弱引用被gc回收后.会把图片在加入到lru中. 然后下次使用再从lru中把图片放到弱引用中.</p>
<p>这里就有个问题. 弱引用指向的对象.在被gc回收后.应该已经不存在了.为何还能加入到lru中.这是因为弱引用在包装引用对象的同时,内部有个属性直接指向了引用对象内部的图片资源.当引用对象被gc后. 再从弱引用中取出这个图片资源.加入到lru中.</p>
<p>首先 图片资源抽象为Resource类. 而在加入弱引用的则是EngineResource.他是对resource的包装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class EngineResource&lt;Z&gt; implements Resource&lt;Z&gt; &#123;</span><br><span class="line">  private final Resource&lt;Z&gt; resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看弱引用如何包装EngineResource, 弱引用类是 ResourceWeakReference, 他通过一个key来标识一个资源.同时内部的resource 则指向被包装的引用的资源.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123;</span><br><span class="line">   @Synthetic final Key key; //标识一个资源的key. lru中也会使用他</span><br><span class="line">  Resource&lt;?&gt; resource;</span><br><span class="line">  ResourceWeakReference(</span><br><span class="line">      @NonNull Key key,</span><br><span class="line">      @NonNull EngineResource&lt;?&gt; referent,</span><br><span class="line">      @NonNull ReferenceQueue&lt;? super EngineResource&lt;?&gt;&gt; queue,</span><br><span class="line">      boolean isActiveResourceRetentionAllowed) &#123;</span><br><span class="line">    super(referent, queue);</span><br><span class="line">    this.key = key;</span><br><span class="line">    this.resource = Preconditions.checkNotNull(referent.getResource())</span><br><span class="line">    //这里最重要, 弱引用的resource ,指向引用对象内的图片资源.当引用对象被回收.这个resource 则使引用对象的图片资源不会被回收.</span><br><span class="line"> 	 &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="弱引用管理ActiveResources"><a href="#弱引用管理ActiveResources" class="headerlink" title="弱引用管理ActiveResources"></a>弱引用管理ActiveResources</h2><p>弱引用的管理类是ActiveResources. 内部维护一个弱引用的hashMap.通过key找到对应的弱引用对象.这个key是在弱引用和lru中公用的用来标识一个资源的对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final class ActiveResources &#123;</span><br><span class="line">  final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources = new HashMap&lt;&gt;();</span><br><span class="line">  private final ReferenceQueue&lt;EngineResource&lt;?&gt;&gt; resourceReferenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用添加"><a href="#弱引用添加" class="headerlink" title="弱引用添加"></a>弱引用添加</h3><p>比较简单,创建弱引用.传入资源和key.然后查找map.如果有旧的弱引用.删除掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">synchronized void activate(Key key, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line"></span><br><span class="line">   ResourceWeakReference toPut =</span><br><span class="line">       new ResourceWeakReference(</span><br><span class="line">           key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">   ResourceWeakReference removed = activeEngineResources.put(key, toPut);</span><br><span class="line">   if (removed != null) &#123;</span><br><span class="line">     removed.reset();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用获取"><a href="#弱引用获取" class="headerlink" title="弱引用获取"></a>弱引用获取</h3><p>从map中查找key对应的弱引用. 如果弱引用包装的对象 active为null了.表示被回收了.那么需要吧弱引用去掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synchronized EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">   ResourceWeakReference activeRef = activeEngineResources.get(key);</span><br><span class="line">   if (activeRef == null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   EngineResource&lt;?&gt; active = activeRef.get();</span><br><span class="line">   if (active == null) &#123;</span><br><span class="line">     cleanupActiveReference(activeRef);</span><br><span class="line">   &#125;</span><br><span class="line">   return active;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="清理弱引用"><a href="#清理弱引用" class="headerlink" title="清理弱引用"></a>清理弱引用</h3><p>清理弱引用时,如果弱引用中的resurce 还有值,就要把这个图片资源加载到lruCache中,</p>
<p>先是从 map中移除掉key对应的弱引用.然后 如果弱引用的resource还有值,就新建一个EngineResource资源.包装这个 resource资源.最后的listener则是Engine. 他会把这个newResource加入到LruCache中.这就实现了.当弱引用包装的对象被gc回收后. 把这个图片资源在保存到lru中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;</span><br><span class="line">  synchronized (listener) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      activeEngineResources.remove(ref.key);</span><br><span class="line"></span><br><span class="line">      if (!ref.isCacheable || ref.resource == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      EngineResource&lt;?&gt; newResource =</span><br><span class="line">          new EngineResource&lt;&gt;(ref.resource,  true,  false);</span><br><span class="line">      newResource.setResourceListener(ref.key, listener);</span><br><span class="line">      listener.onResourceReleased(ref.key, newResource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取图片内存缓存"><a href="#取图片内存缓存" class="headerlink" title="取图片内存缓存"></a>取图片内存缓存</h2><p>方法是从Engine的load开始.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public synchronized &lt;R&gt; LoadStatus load(...</span><br><span class="line"> 先生产图片资源对应的key.缓存key是实现内存和磁盘缓存的唯一标识</span><br><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">        resourceClass, transcodeClass, options);</span><br><span class="line">		//从弱引用map中找到资源,如果有就返回</span><br><span class="line">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line">    if (active != null) &#123;</span><br><span class="line">      cb.onResourceReady(active, DataSource.MEMORY_CACHE);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">	//从lrucache中读取图片资源.有就返回</span><br><span class="line">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line">    if (cached != null) &#123;</span><br><span class="line">      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadFromActiveResources 很简单.就是从上边的ActiveResources中读取EngineResource.</p>
<p>看看如何从lrucache中读取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123;</span><br><span class="line">//从lru中找到资源.</span><br><span class="line">  EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class="line">  //如果可已缓存,则把图片加入到 弱引用缓存中.</span><br><span class="line">  if (cached != null) &#123;</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line">  Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class="line">//可以看到,竟然是从lrucache中remove掉对应的资源. 然后进行封装.</span><br><span class="line">  final EngineResource&lt;?&gt; result;</span><br><span class="line">  if (cached == null) &#123;</span><br><span class="line">    result = null;</span><br><span class="line">  &#125; else if (cached instanceof EngineResource) &#123;</span><br><span class="line">    // Save an object allocation if we&apos;ve cached an EngineResource (the typical case).</span><br><span class="line">    result = (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = new EngineResource&lt;&gt;(cached, true , true );</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到.一个资源.通过key来唯一标识. 并且在使用时总是在弱引用map中. 如果不在.就从lru缓存中把他删除.在加入到弱引用map中.而当从弱引用中清除时,在加入会lru中. 这就使一个图片在内存中只能有一份.</p>
<h2 id="LruResourceCache"><a href="#LruResourceCache" class="headerlink" title="LruResourceCache"></a>LruResourceCache</h2><p>LruCache 是 最近最少使用 算法的缓存,它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。</p>
<p>LruCache内部维护一个LinkedHashMap.每添加一个 item.就计算下item的尺寸和当前容量.如果加起来超过最大容量 了.就先把item加进来.在跳转linkedHashMap的容量. 做法就是得到迭代器.从头到尾.删除元素,删除一个从新计算下当前容量.若果还大于最大容量.就继续删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LruCache&lt;T, Y&gt; &#123;</span><br><span class="line">//保存数据的集合.</span><br><span class="line">  private final Map&lt;T, Y&gt; cache = new LinkedHashMap&lt;&gt;(100, 0.75f, true);</span><br><span class="line">  private final long initialMaxSize;  初始化容量和最大容量</span><br><span class="line">  private long maxSize;</span><br><span class="line">  private long currentSize; 当前容量</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>计算item的容量.删除旧的item.看看是否要优化linkedHashMap的容量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Y put(@NonNull T key, @Nullable Y item) &#123;</span><br><span class="line">   final int itemSize = getSize(item); </span><br><span class="line">   if (itemSize &gt;= maxSize) &#123; //item超过最大容量.不让添加</span><br><span class="line">     onItemEvicted(key, item);</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (item != null) &#123;</span><br><span class="line">     currentSize += itemSize;</span><br><span class="line">   &#125;  //保存新的item. 替换旧的item</span><br><span class="line">   @Nullable final Y old = cache.put(key, item);</span><br><span class="line">   if (old != null) &#123;</span><br><span class="line">     currentSize -= getSize(old);</span><br><span class="line"></span><br><span class="line">     if (!old.equals(item)) &#123;</span><br><span class="line">       onItemEvicted(key, old);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //优化容量.</span><br><span class="line">   evict();</span><br><span class="line"></span><br><span class="line">   return old;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化容量"><a href="#优化容量" class="headerlink" title="优化容量"></a>优化容量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> protected synchronized void trimToSize(long size) &#123;</span><br><span class="line">   Map.Entry&lt;T, Y&gt; last;</span><br><span class="line">   Iterator&lt;Map.Entry&lt;T, Y&gt;&gt; cacheIterator;</span><br><span class="line">   while (currentSize &gt; size) &#123;</span><br><span class="line">   //拿到linkedhashMap的迭代器. </span><br><span class="line">     cacheIterator  = cache.entrySet().iterator();</span><br><span class="line">     //从头开始取出一项,计算尺寸, 然后删除.直到当前容量小于最大容量.</span><br><span class="line">     last = cacheIterator.next();</span><br><span class="line">     final Y toRemove = last.getValue();</span><br><span class="line">     currentSize -= getSize(toRemove);</span><br><span class="line">     final T key = last.getKey();</span><br><span class="line">     cacheIterator.remove();</span><br><span class="line">     onItemEvicted(key, toRemove);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">//优化至最大容量</span><br><span class="line"> private void evict() &#123;</span><br><span class="line">   trimToSize(maxSize);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>config.   Size    current(保留的数量)</p>
<p>1                多        多</p>
<h1 id="bitmap对象池"><a href="#bitmap对象池" class="headerlink" title="bitmap对象池"></a>bitmap对象池</h1><p>LruBitmapPool 是bitmap对象池,他保存许多bitmap.提供给外界使用.然后在外边使用完成后在加入到对象池中,减少bitmap的创建和销毁.因为bitmap就是一段图片的内存.几个类介绍如下</p>
<p>Key. 一个key来标识一个bitmap. key则是由bitmap的字节大小和config封装而成.</p>
<p>SizeConfigStrategy 是bitmap的查找和存储规则类,他负责根据提供的字节大小和config.选出合适的bitmap.</p>
<p>这里大体的流程是LruBitmapPool 通过SizeConfigStrategy来管理所有的bitmap的添加查找. 并且通过lruCache机制控制所以bitmap占用内存的大小.超过了就删除最佳最少使用的bitmap.</p>
<h2 id="SizeConfigStrategy"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h2><p>内部有两个结合. 一个是通过key保存所有的bitmap. 一个是通过bitmap的config 来保存这种config类型下.有多少个尺寸的bitmap及bitmap 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final GroupedLinkedMap&lt;Key, Bitmap&gt; groupedMap = new GroupedLinkedMap&lt;&gt;();</span><br><span class="line">private final Map&lt;Bitmap.Config, NavigableMap&lt;Integer, Integer&gt;&gt; sortedSizes = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>原理比较简单. 先得到bitmap的内存大小.然后size和 config 生成一个唯一的key. 并把这个bitmap加入到groupedMap中. 最后在通过config 找到该config下所有的size  的数量.</p>
<p>keypool 是一个生产key的对象池.很简单.</p>
<p>config 的类型有如下几种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static Config sConfigs[] = &#123;</span><br><span class="line">    null, ALPHA_8, null, RGB_565, ARGB_4444, ARGB_8888, RGBA_F16, HARDWARE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>找到某个config 下的所有尺寸的匹配数量的map.然后再把该数量加1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private NavigableMap&lt;Integer, Integer&gt; getSizesForConfig(Bitmap.Config config) &#123;</span><br><span class="line">  NavigableMap&lt;Integer, Integer&gt; sizes = sortedSizes.get(config);</span><br><span class="line">  if (sizes == null) &#123;</span><br><span class="line">    sizes = new TreeMap&lt;&gt;();</span><br><span class="line">    sortedSizes.put(config, sizes);</span><br><span class="line">  &#125;</span><br><span class="line">  return sizes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void put(Bitmap bitmap) &#123;</span><br><span class="line">  int size = Util.getBitmapByteSize(bitmap);</span><br><span class="line">  Key key = keyPool.get(size, bitmap.getConfig());</span><br><span class="line"></span><br><span class="line">  groupedMap.put(key, bitmap);</span><br><span class="line">//可以看到这里是以bitmap的size作为key.来保存统一size下</span><br><span class="line">  NavigableMap&lt;Integer, Integer&gt; sizes = getSizesForConfig(bitmap.getConfig());</span><br><span class="line">  Integer current = sizes.get(key.size);</span><br><span class="line">  sizes.put(key.size, current == null ? 1 : current + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里.加入我们添加一个bitmap. 他的config是RGB_565,size是100,则在groupedMap里有个RGB_(565,100)为key.的bitmap .</p>
<p>而在 sortedSizes里.通过config 为RGB_565 可以得到一个 size 的map/ 里边有数据(100,1).</p>
<p>当我们添加一个config相同. size是200的bitmap. groupedMap 就会有两个bitmap了.而sortedSizes里.通过config 为RGB_565,就有 (100,1)(200,1) 两组数据. 也就是保留了同一种config下.不同size的数量了.</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>通过 指定的bitmap.Config和宽高.来得到合适的图片.</p>
<p>先是计算出要得到的size. 做发就是宽 * 高 * 图片每位的字节数.</p>
<p>通过findBestKey 在sortedSizes查找到合适的组合,然后封装成key. 在用这个key去得到对应的bitmap.这个bitmap的尺寸可能和需求的不一样.就需要reconfigure 来从新配置该bitmap</p>
<p>这里的精华在findBestKey</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap get(int width, int height, Bitmap.Config config) &#123;</span><br><span class="line">  int size = Util.getBitmapByteSize(width, height, config);</span><br><span class="line">  Key bestKey = findBestKey(size, config);</span><br><span class="line"></span><br><span class="line">  Bitmap result = groupedMap.get(bestKey);</span><br><span class="line">  if (result != null) &#123;</span><br><span class="line">    // Decrement must be called before reconfigure.</span><br><span class="line">    decrementBitmapOfSize(bestKey.size, result);</span><br><span class="line">    result.reconfigure(width, height, config);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先根据需要的尺寸生产一个key.</p>
<p>然后通过传入的config.在sortedSizes里找到所有的&lt;size,num&gt;的map.也就是拿到这种config里所有可用的size及对应的个数.也就是上文的(100,1)(200,1)的数据.</p>
<p> sizesForPossibleConfig.ceilingKey(size);  则是找到比size大的最接近的key, 比如 size 是99.那么因为map里只有(100,1)(200,1), 就找到100这个尺寸.. 其实也就是找到比需要的bitmap尺寸大一点的合适的bitmap的size.</p>
<p>最后得到的就是 原有保存了.最进行需要的尺寸的bitmap.的key.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Key findBestKey(int size, Bitmap.Config config) &#123;</span><br><span class="line">  Key result = keyPool.get(size, config);</span><br><span class="line">  for (Bitmap.Config possibleConfig : getInConfigs(config)) &#123;</span><br><span class="line">    NavigableMap&lt;Integer, Integer&gt; sizesForPossibleConfig = getSizesForConfig(possibleConfig);</span><br><span class="line">    //找到合适的size.生成key. 最大的possibleSize不能大于size * 8</span><br><span class="line">    Integer possibleSize = sizesForPossibleConfig.ceilingKey(size);</span><br><span class="line">    if (possibleSize != null &amp;&amp; possibleSize &lt;= size * MAX_SIZE_MULTIPLE) &#123;</span><br><span class="line">      if (possibleSize != size</span><br><span class="line">          || (possibleConfig == null ? config != null : !possibleConfig.equals(config))) &#123;</span><br><span class="line">        keyPool.offer(result);</span><br><span class="line">        result = keyPool.get(possibleSize, possibleConfig);</span><br><span class="line">      &#125;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看到. 查找时先匹配config.在匹配尺寸.找一个大于等于需求尺寸的size.然后在得到对应的bitmap. 在把这个bitmap从新配置成需求的宽高.提供出去.</p>
<p>比如传入的是  88,RGB_565 的尺寸, 我们会匹配到 100,RGB_565.的bitmap. 然后通过bitmap.reconfigure. 把 100的尺寸改完传入的88. 这样就复用了这个bitmap.</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除最后一个bitmap. 并删除对应的size 计数.如果对于的size的技术为0.把这个size的key也删掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap removeLast() &#123;</span><br><span class="line">  Bitmap removed = groupedMap.removeLast();</span><br><span class="line">  if (removed != null) &#123;</span><br><span class="line">    int removedSize = Util.getBitmapByteSize(removed);</span><br><span class="line">    decrementBitmapOfSize(removedSize, removed);</span><br><span class="line">  &#125;</span><br><span class="line">  return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LruBitmapPool"><a href="#LruBitmapPool" class="headerlink" title="LruBitmapPool"></a>LruBitmapPool</h2><p>bitmap对象池内部.通过SizeConfigStrategy增删图片. 他只负责控制对象池的整体大小.</p>
<h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><p>把图片添加到 SizeConfigStrategy中,并计算依据添加的容量大小.通过 evict控制总容量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void put(Bitmap bitmap) &#123;</span><br><span class="line"></span><br><span class="line">  final int size = strategy.getSize(bitmap);</span><br><span class="line">  strategy.put(bitmap);</span><br><span class="line">  tracker.add(bitmap);</span><br><span class="line"></span><br><span class="line">  puts++;</span><br><span class="line">  currentSize += size;</span><br><span class="line"></span><br><span class="line">  evict();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>找到能复用的bitmap. 清除为透明色,否则就创建一个固定宽高的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap get(int width, int height, Bitmap.Config config) &#123;</span><br><span class="line">  Bitmap result = getDirtyOrNull(width, height, config);</span><br><span class="line">  if (result != null) &#123;</span><br><span class="line">    result.eraseColor(Color.TRANSPARENT);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = createBitmap(width, height, config);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 sizeConfigStrategy里找到合适的bitmap..然后减少当前保存的bitmap容量.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private synchronized Bitmap getDirtyOrNull(</span><br><span class="line">    int width, int height, @Nullable Bitmap.Config config) &#123;</span><br><span class="line">  assertNotHardwareConfig(config);</span><br><span class="line">  final Bitmap result = strategy.get(width, height, config != null ? config : DEFAULT_CONFIG);</span><br><span class="line">  if (result == null) &#123;</span><br><span class="line">    misses++;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    hits++;</span><br><span class="line">    currentSize -= strategy.getSize(result);</span><br><span class="line">    tracker.remove(result);</span><br><span class="line">    normalize(result);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="容量控制"><a href="#容量控制" class="headerlink" title="容量控制"></a>容量控制</h3><p>从后向前删除bitmap.直到当前容量小于要求的容量. 然后用bitmap.recycle.来回收.很简单.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void trimToSize(long size) &#123;</span><br><span class="line">  while (currentSize &gt; size) &#123;</span><br><span class="line">    final Bitmap removed = strategy.removeLast();</span><br><span class="line">    if (removed == null) &#123;</span><br><span class="line">      currentSize = 0;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    tracker.remove(removed);</span><br><span class="line">    currentSize -= strategy.getSize(removed);</span><br><span class="line">    evictions++;</span><br><span class="line">    removed.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/d6cae68175f2" target="_blank" rel="noopener">https://www.jianshu.com/p/d6cae68175f2</a> 这个讲解比较细.</p>
<p><a href="https://zhuanlan.zhihu.com/p/60426316" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60426316</a> 这个也很不错.</p>
<p><a href="https://www.codercto.com/a/53115.html" target="_blank" rel="noopener">https://www.codercto.com/a/53115.html</a></p>
<h1 id="bitmap-采样"><a href="#bitmap-采样" class="headerlink" title="bitmap 采样"></a>bitmap 采样</h1><p><a href="https://www.codercto.com/a/52496.html" target="_blank" rel="noopener">https://www.codercto.com/a/52496.html</a>  这个牛逼.</p>
<p>bitmapOpeions的参数详解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Bitmap inBitmap;  //是否重用该Bitmap，注意使用条件，Bitmap的大小必须等于inBitmap，inMutable为true</span><br><span class="line">public boolean inMutable;  //设置Bitmap是否可以更改</span><br><span class="line">public boolean inJustDecodeBounds; // true时，decode不会创建Bitmap对象，但是可以获取图片的宽高</span><br><span class="line">public int inSampleSize;  // 压缩比例，比如=4，代表宽高压缩成原来的1/4，注意该值必须&gt;=1</span><br><span class="line">public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;  //Bitmap.Config，默认为ARGB_8888</span><br><span class="line">public boolean inPremultiplied; //默认为true，一般不需要修改，如果想要修改图片原始编码数据，那么需要修改</span><br><span class="line">public boolean inDither; //是否抖动，默认为false</span><br><span class="line">public int inDensity; //Bitmap的像素密度</span><br><span class="line">public int inTargetDensity; //Bitmap最终的像素密度(注意，inDensity，inTargetDensity影响图片的缩放度)</span><br><span class="line">public int inScreenDensity; //当前屏幕的像素密度</span><br><span class="line">public boolean inScaled; //是否支持缩放，默认为true，当设置了这个，Bitmap将会以inTargetDensity的值进行缩放</span><br><span class="line">public boolean inPurgeable; //当存储Pixel的内存空间在系统内存不足时是否可以被回收</span><br><span class="line">public boolean inInputShareable; //inPurgeable为true情况下才生效，是否可以共享一个InputStream</span><br><span class="line">public boolean inPreferQualityOverSpeed; //为true则优先保证Bitmap质量其次是解码速度</span><br><span class="line">public int outWidth; //Bitmap最终的宽</span><br><span class="line">public int outHeight;  //Bitmap最终的高</span><br><span class="line">public String outMimeType; //</span><br><span class="line">public byte[] inTempStorage; //解码时的临时空间，建议16*1024</span><br></pre></td></tr></table></figure>

<h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><p>所有的模块都在这里注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final ModelLoaderRegistry modelLoaderRegistry;</span><br><span class="line">private final EncoderRegistry encoderRegistry;</span><br><span class="line">private final ResourceDecoderRegistry decoderRegistry;</span><br><span class="line">private final ResourceEncoderRegistry resourceEncoderRegistry;</span><br><span class="line">private final DataRewinderRegistry dataRewinderRegistry;</span><br><span class="line">private final TranscoderRegistry transcoderRegistry;</span><br><span class="line">private final ImageHeaderParserRegistry imageHeaderParserRegistry;</span><br><span class="line"></span><br><span class="line">private final ModelToResourceClassCache modelToResourceClassCache =</span><br><span class="line">    new ModelToResourceClassCache();</span><br><span class="line">private final LoadPathCache loadPathCache = new LoadPathCache();</span><br><span class="line">private final Pool&lt;List&lt;Throwable&gt;&gt; throwableListPool = FactoryPools.threadSafeList();</span><br></pre></td></tr></table></figure>

<p>这个类里有大量的append.register.prepend.用来把各种模块追加到上边的各种注册器里边.</p>
<p><img src="/2020/03/17/glide-源码解析/image-20200324213130912.png" alt="image-20200324213130912"></p>
<p>这里的每个registry都是负责一个模块的功能的注册加载的.下边简单分别看看</p>
<h2 id="ModelLoaderRegistry"><a href="#ModelLoaderRegistry" class="headerlink" title="ModelLoaderRegistry"></a>ModelLoaderRegistry</h2><p>负责注册 数据加载模块.重要属性是MultiModelLoaderFactory,注册的模块都是注册到MultiModelLoaderFactory中了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final MultiModelLoaderFactory multiModelLoaderFactory;</span><br><span class="line">  private final ModelLoaderCache cache = new ModelLoaderCache();</span><br><span class="line">public synchronized &lt;Model, Data&gt; void append(</span><br><span class="line">    @NonNull Class&lt;Model&gt; modelClass,</span><br><span class="line">    @NonNull Class&lt;Data&gt; dataClass,</span><br><span class="line">    @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory) &#123;</span><br><span class="line">  multiModelLoaderFactory.append(modelClass, dataClass, factory);</span><br><span class="line">  cache.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MultiModelLoaderFactory"><a href="#MultiModelLoaderFactory" class="headerlink" title="MultiModelLoaderFactory"></a>MultiModelLoaderFactory</h3><p>MultiModelLoaderFactory内部,可以看到所以的模块都封装成了 Entry. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  private final List&lt;Entry&lt;?, ?&gt;&gt; entries = new ArrayList&lt;&gt;();</span><br><span class="line">private &lt;Model, Data&gt; void add(</span><br><span class="line">    @NonNull Class&lt;Model&gt; modelClass,</span><br><span class="line">    @NonNull Class&lt;Data&gt; dataClass,</span><br><span class="line">    @NonNull ModelLoaderFactory&lt;? extends Model, ? extends Data&gt; factory,</span><br><span class="line">    boolean append) &#123;</span><br><span class="line">  Entry&lt;Model, Data&gt; entry = new Entry&lt;&gt;(modelClass, dataClass, factory);</span><br><span class="line">  entries.add(append ? entries.size() : 0, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的build 方法.会遍历 所以entry. 找到与modleclass匹配的entry然后执行这个entry的build方法.最后返回出所有匹配的modelLoder集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">synchronized &lt;Model&gt; List&lt;ModelLoader&lt;Model, ?&gt;&gt; build(@NonNull Class&lt;Model&gt; modelClass) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    List&lt;ModelLoader&lt;Model, ?&gt;&gt; loaders = new ArrayList&lt;&gt;();</span><br><span class="line">    for (Entry&lt;?, ?&gt; entry : entries) &#123;</span><br><span class="line">      if (entry.handles(modelClass)) &#123;</span><br><span class="line">        alreadyUsedEntries.add(entry);</span><br><span class="line">        //调用entry的build</span><br><span class="line">        loaders.add(this.&lt;Model, Object&gt;build(entry));</span><br><span class="line">        alreadyUsedEntries.remove(entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loaders;</span><br><span class="line">  &#125; catch (Throwable t) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看着和抽象.看个他的实例.</p>
<h3 id="HttpGlideUrlLoader"><a href="#HttpGlideUrlLoader" class="headerlink" title="HttpGlideUrlLoader"></a>HttpGlideUrlLoader</h3><p>HttpUriLoader有个静态内部类Factory继承自MultiModelLoaderFactory.因此他的build方法会执行.可以看到.一个Factory和一个ModleLoader 是绑定的.这应该算工厂模式.但是我觉得有点复杂了.其实没必要加这个工厂.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ModelLoader&lt;Uri, InputStream&gt; build(MultiModelLoaderFactory multiFactory) &#123;</span><br><span class="line">  return new HttpUriLoader(multiFactory.build(GlideUrl.class, InputStream.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpGlideUrlLoader继承自 ModelLoader.最重要的就是BuildLoadData方法. 也就是加载想要的数据,</p>
<p>先找缓存.如果没有.就新建一个loadData返回. 这里又创建了HttpUrlFetcher.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public LoadData&lt;InputStream&gt; buildLoadData(@NonNull GlideUrl model, int width, int height,</span><br><span class="line">     @NonNull Options options) &#123;</span><br><span class="line">   GlideUrl url = model;</span><br><span class="line">   if (modelCache != null) &#123;</span><br><span class="line">     url = modelCache.get(model, 0, 0);</span><br><span class="line">     if (url == null) &#123;</span><br><span class="line">       modelCache.put(model, 0, 0, model);</span><br><span class="line">       url = model;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url, timeout));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HttpUrlFetcher"><a href="#HttpUrlFetcher" class="headerlink" title="HttpUrlFetcher"></a>HttpUrlFetcher</h3><p>HttpUrlFetcher又继承自DataFetcher.是获取数据的真正类.重要方法是loadData.参数有一个callback.通过callback把数据返回, 这里是用url 创建一个HttpURLConnection. 连接后获取一个inputStream提供给callback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void loadData(@NonNull Priority priority,</span><br><span class="line">    @NonNull DataCallback&lt;? super InputStream&gt; callback) &#123;</span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());</span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ModelLoaderRegistry里注册了很多的ModelLoaderFactory.而ModelLoaderFactory的实现类又往往和一个ModelLoader的实现类绑定起来. ModelLoaderFactory就是工厂模式.他的build.就向往提供这个modelLoader.</p>
<p>ModelLoader最重要的方法是buildLoadData,也就是根据参数返回一个loadData(加载的数据).不同的ModelLoader产生不同的loadData.但是最终都是由DataFetcher 来完成数据的真正获取.</p>
<p>大概就是这么个关系. 其实就是个加载数据的模块.根据泛型来判断.但是使用了工厂模式.并进行了抽象</p>
<p><img src="/2020/03/17/glide-源码解析/image-20200324223604817.png" alt="image-20200324223604817"></p>
<h2 id="EncoderRegistry"><a href="#EncoderRegistry" class="headerlink" title="EncoderRegistry"></a>EncoderRegistry</h2><p>这是把数据编码保存到文件中的注册器. 工作就是把内存中的各种图片.保存到文件中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> private final List&lt;Entry&lt;?&gt;&gt; encoders = new ArrayList&lt;&gt;();</span><br><span class="line">public synchronized &lt;T&gt; void append(@NonNull Class&lt;T&gt; dataClass, @NonNull Encoder&lt;T&gt; encoder) &#123;</span><br><span class="line">   encoders.add(new Entry&lt;&gt;(dataClass, encoder));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到添加的都是Encoder. 有如下几个子类. 主要方法是encode.这个比较简单.看下BitmapEncoder</p>
<p><img src="/2020/03/17/glide-源码解析/image-20200324224438010.png" alt="image-20200324224438010"></p>
<h3 id="BitmapEncoder"><a href="#BitmapEncoder" class="headerlink" title="BitmapEncoder"></a>BitmapEncoder</h3><p>很简单.就是通过流把bitmap保存.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean encode( Resource&lt;Bitmap&gt; resource,  File file,Options options) &#123;</span><br><span class="line">    final Bitmap bitmap = resource.get();</span><br><span class="line">    Bitmap.CompressFormat format = getFormat(bitmap, options);</span><br><span class="line">      int quality = options.get(COMPRESSION_QUALITY);</span><br><span class="line">      OutputStream os = null;</span><br><span class="line">      try &#123;</span><br><span class="line">        os = new FileOutputStream(file);</span><br><span class="line">        bitmap.compress(format, quality, os);</span><br><span class="line">        os.close();</span><br><span class="line">        success = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ResourceDecoderRegistry"><a href="#ResourceDecoderRegistry" class="headerlink" title="ResourceDecoderRegistry"></a>ResourceDecoderRegistry</h2><p>按名称.应该是从文件或者其他地方解码出图片到内存中. 所有的registry都是一个用来保存改功能的集合.主要还是看里边的实现. 这里主要是ResourceDecoder,有如下这些,主要的方法就是decode.返回一个resource资源.</p>
<p><img src="/2020/03/17/glide-源码解析/image-20200324225136996.png" alt="image-20200324225136996"></p>
<p>看下 ByteBufferBitmapDecoder的处理.这个是比较复杂的</p>
<h3 id="ByteBufferBitmapDecoder"><a href="#ByteBufferBitmapDecoder" class="headerlink" title="ByteBufferBitmapDecoder"></a>ByteBufferBitmapDecoder</h3><p>先把byteBuffer 包装成了ByteBufferStream. 又通过Downsampler 来decode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width, int height,</span><br><span class="line">    @NonNull Options options)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  InputStream is = ByteBufferUtil.toStream(source);</span><br><span class="line">  return downsampler.decode(is, width, height, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Downsampler"><a href="#Downsampler" class="headerlink" title="Downsampler"></a>Downsampler</h3><p>这里显示通过options 的各种默认参数. 来封装BitMapFactory.options,可以看到的是.连读取流使用byte[]  缓冲都是使用了对象池. glide对象池的引用针对是很广了.</p>
<p>继续通过decodeFromWrappedStreams 来获取bitmap.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight,</span><br><span class="line">    Options options, DecodeCallbacks callbacks) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">  byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);</span><br><span class="line">  BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();</span><br><span class="line">  bitmapFactoryOptions.inTempStorage = bytesForOptions;</span><br><span class="line"></span><br><span class="line">  DecodeFormat decodeFormat = options.get(DECODE_FORMAT);</span><br><span class="line">  </span><br><span class="line">  try &#123;</span><br><span class="line">    Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,</span><br><span class="line">        downsampleStrategy, decodeFormat, isHardwareConfigAllowed, requestedWidth,</span><br><span class="line">        requestedHeight, fixBitmapToRequestedDimensions, callbacks);</span><br><span class="line">        //这里还绑定了bitmap 和bigmap对象池. 用来在bitmap用完时进行回收.</span><br><span class="line">    return BitmapResource.obtain(result, bitmapPool);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    releaseOptions(bitmapFactoryOptions);</span><br><span class="line">    byteArrayPool.put(bytesForOptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑更复杂. 删掉一些不重要代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private Bitmap decodeFromWrappedStreams(InputStream is,</span><br><span class="line">    BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,</span><br><span class="line">    DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,</span><br><span class="line">    int requestedHeight, boolean fixBitmapToRequestedDimensions,</span><br><span class="line">    DecodeCallbacks callbacks) throws IOException &#123;</span><br><span class="line">//得到 图片的宽高.</span><br><span class="line">  int[] sourceDimensions = getDimensions(is, options, callbacks, bitmapPool);</span><br><span class="line">  int sourceWidth = sourceDimensions[0];</span><br><span class="line">  int sourceHeight = sourceDimensions[1];</span><br><span class="line"></span><br><span class="line">	//解析inputStream. 得到图片的选旋转方向和旋转角度</span><br><span class="line">  int orientation = ImageHeaderParserUtils.getOrientation(parsers, is, byteArrayPool);</span><br><span class="line">  int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);</span><br><span class="line">	//如果有请求设定的宽高.就是用他.否则使用图片宽高. 通常glide都会把图片缩放成imageview的宽高.</span><br><span class="line">	int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;</span><br><span class="line">  int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;</span><br><span class="line"></span><br><span class="line">	//进行图片缩放比例的确定, 这里设置了各种BitMapFactory.Options的参数</span><br><span class="line">  calculateScaling(</span><br><span class="line">      imageType,</span><br><span class="line">      is,</span><br><span class="line">      callbacks,</span><br><span class="line">      bitmapPool,</span><br><span class="line">      downsampleStrategy,</span><br><span class="line">      degreesToRotate,</span><br><span class="line">      sourceWidth,</span><br><span class="line">      sourceHeight,</span><br><span class="line">      targetWidth,</span><br><span class="line">      targetHeight,</span><br><span class="line">      options);</span><br><span class="line">   //这里设置的 BitMapFactory.Options.inPreferredConfig 也就是图片格式   </span><br><span class="line">  calculateConfig(</span><br><span class="line">      is,</span><br><span class="line">      decodeFormat,</span><br><span class="line">      isHardwareConfigAllowed,</span><br><span class="line">      isExifOrientationRequired,</span><br><span class="line">      options,</span><br><span class="line">      targetWidth,</span><br><span class="line">      targetHeight);</span><br><span class="line">	//这里根据inSampleSize 的值 和图片的dpi.要显示view的dpi.来确定最后的图片尺寸expectWidth expectHeight</span><br><span class="line">  if ((options.inSampleSize == 1 || isKitKatOrGreater) &amp;&amp; shouldUsePool(imageType)) &#123;</span><br><span class="line">    int expectedWidth;</span><br><span class="line">    int expectedHeight;</span><br><span class="line">      expectedWidth = targetWidth;</span><br><span class="line">      expectedHeight = targetHeight;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float densityMultiplier = isScaling(options)</span><br><span class="line">          ? (float) options.inTargetDensity / options.inDensity : 1f;</span><br><span class="line">      int sampleSize = options.inSampleSize;</span><br><span class="line">      int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);</span><br><span class="line">      int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);</span><br><span class="line">      expectedWidth = Math.round(downsampledWidth * densityMultiplier);</span><br><span class="line">      expectedHeight = Math.round(downsampledHeight * densityMultiplier);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//设置BitMapFactory.options. inBitmap. 用期望的尺寸去bitmapPool对象池找到合适的bitmap来复用</span><br><span class="line">      setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);</span><br><span class="line">      //BitMapFactory 来decodeStream .生成bitmap,这里没什么了.因为前边把options的参数都确定了.</span><br><span class="line">  Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);</span><br><span class="line">	//旋转图片</span><br><span class="line">   Bitmap   rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);</span><br><span class="line"></span><br><span class="line">		//回收bitmap</span><br><span class="line">    if (!downsampled.equals(rotated)) &#123;</span><br><span class="line">      bitmapPool.put(downsampled);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	返回最后的结果,旋转后的bitmap</span><br><span class="line">  return rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>decoder 就是把参数转换成bitmap资源的地方. 这里有多个方式可以转换, 上班的DownSampler.里通过设置BitMapFactory.options.和bitmap对象池的复用.比较高效的转换了bitmap. 其他还有从文件中加载等等.</p>
<h2 id="ResourceEncoderRegistry"><a href="#ResourceEncoderRegistry" class="headerlink" title="ResourceEncoderRegistry"></a>ResourceEncoderRegistry</h2><p>也是一个管理类.重要的是里边的ResourceEncoder.  他和之前的EncoderRegistry 是一样的. 都是encode方法吧资源保存到文件中.</p>
<h2 id="DataRewinderRegistry"><a href="#DataRewinderRegistry" class="headerlink" title="DataRewinderRegistry"></a>DataRewinderRegistry</h2><p>这也是负责管理这模块的所有类的集合. 主要的类是DataRewinder,主要方法是rewindAndGet(),</p>
<p>这个功能的翻译是 数据回卷器. 其实就是进行数据读取回到原位置..</p>
<p><img src="/2020/03/17/glide-源码解析/image-20200325105633335.png" alt="image-20200325105633335"></p>
<h3 id="InputStreamRewinder"><a href="#InputStreamRewinder" class="headerlink" title="InputStreamRewinder"></a>InputStreamRewinder</h3><p>对输入流的回卷操作. 可以看到 mark和reset 是对应的.也就是mark最大读取的字节数是5kb.然后回卷后可以重新读取这5kb的数据. 这是流的数据的复用.也就是可以重复读取这5kb的数据.</p>
<p>这个mark保持有效。比如说mark(10)，那么在read()10个以内的字符时，reset（）操作后可以重新读取已经读出的数据，如果已经读取的数据超过10个，那reset()操作后，就不能正确读取以前的数据了，因为此时mark标记已经失效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  private static final int MARK_LIMIT = 5 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">@Synthetic</span><br><span class="line">  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) &#123;</span><br><span class="line">    bufferedStream = new RecyclableBufferedInputStream(is, byteArrayPool);</span><br><span class="line">    bufferedStream.mark(MARK_LIMIT);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">  @Override</span><br><span class="line">  public InputStream rewindAndGet() throws IOException &#123;</span><br><span class="line">    bufferedStream.reset();</span><br><span class="line">    return bufferedStream;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这就是反复读取同一段数据的一个操作类.</p>
<h2 id="TranscoderRegistry"><a href="#TranscoderRegistry" class="headerlink" title="TranscoderRegistry"></a>TranscoderRegistry</h2><p>这是一个数据转换类. 内部的Entry 结构很清楚, 从什么格式,转换到什么格式. 使用什么ResourceTranscoder转换器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final Class&lt;Z&gt; fromClass;</span><br><span class="line">private final Class&lt;R&gt; toClass;</span><br><span class="line">@Synthetic final ResourceTranscoder&lt;Z, R&gt; transcoder;</span><br></pre></td></tr></table></figure>

<p>ResourceTranscoder 只有一个transcode 方法.Resource<r> transcode(Resource<z> toTranscode,Options options); 就是把格式Z转换为格式R,实现类如下</z></r></p>
<p><img src="/2020/03/17/glide-源码解析/image-20200325111339778.png" alt="image-20200325111339778"></p>
<h2 id="BitmapBytesTranscoder"><a href="#BitmapBytesTranscoder" class="headerlink" title="BitmapBytesTranscoder"></a>BitmapBytesTranscoder</h2><p>把一个bitmap 转成byte 数组返回. 其实是使用bitmap.compress 来实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Resource&lt;byte[]&gt; transcode(@NonNull Resource&lt;Bitmap&gt; toTranscode,</span><br><span class="line">    @NonNull Options options) &#123;</span><br><span class="line">  ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="line">  toTranscode.get().compress(compressFormat, quality, os);</span><br><span class="line">  toTranscode.recycle();</span><br><span class="line">  return new BytesResource(os.toByteArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>被注册组件的集合（包括默认被 Glide 注册的和在 Module 中被注册的），会被用于定义一个加载路径集合。每个加载路径都是从提供给 <code>load</code> 方法的数据模型到 <code>as</code> 方法指定的资源类型的一个逐步演进的过程。一个加载路径（粗略地）由下列步骤组成:</p>
<ol>
<li>模型 <code>(Model)</code> -&gt; 数据 <code>(Data)</code> (由模型加载器 <code>(ModelLoader)</code> 处理)</li>
<li>数据 <code>(Data)</code> -&gt; 资源 <code>(Resource)</code> (由资源解析器 <code>(ResourceDecoder)</code> 处理)</li>
<li>资源 <code>(Resource)</code> -&gt; 转码后的资源 <code>(Transcoded Resource)</code> (可选；由资源转码器 <code>(ResourceTranscoder)</code> 处理)</li>
</ol>
<p>编码器 <code>(Encoder)</code> 可以在步骤 2 之前往 Glide 的磁盘缓存中写入数据。资源编码器 <code>(ResourceEncoder)</code> 可以在步骤 3 之前往 Glide 的磁盘缓存写入资源。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/android工具源码/" rel="tag"># android工具源码</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/03/17/图床/glide-源码解析图床版/" rel="next" title="glide-源码解析-图床版">
                  <i class="fa fa-chevron-left"></i> glide-源码解析-图床版
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2020/03/25/okhttp源码解析/" rel="prev" title="okhttp源码解析">
                  okhttp源码解析 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liujiakuo</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#With"><span class="nav-text">With</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#load"><span class="nav-text">load</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#into"><span class="nav-text">into</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存缓存原理"><span class="nav-text">内存缓存原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#弱引用管理ActiveResources"><span class="nav-text">弱引用管理ActiveResources</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用添加"><span class="nav-text">弱引用添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用获取"><span class="nav-text">弱引用获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清理弱引用"><span class="nav-text">清理弱引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取图片内存缓存"><span class="nav-text">取图片内存缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LruResourceCache"><span class="nav-text">LruResourceCache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加数据"><span class="nav-text">添加数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化容量"><span class="nav-text">优化容量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bitmap对象池"><span class="nav-text">bitmap对象池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SizeConfigStrategy"><span class="nav-text">SizeConfigStrategy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加"><span class="nav-text">添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LruBitmapPool"><span class="nav-text">LruBitmapPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加-1"><span class="nav-text">添加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取"><span class="nav-text">获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容量控制"><span class="nav-text">容量控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bitmap-采样"><span class="nav-text">bitmap 采样</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Registry"><span class="nav-text">Registry</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ModelLoaderRegistry"><span class="nav-text">ModelLoaderRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MultiModelLoaderFactory"><span class="nav-text">MultiModelLoaderFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HttpGlideUrlLoader"><span class="nav-text">HttpGlideUrlLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HttpUrlFetcher"><span class="nav-text">HttpUrlFetcher</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EncoderRegistry"><span class="nav-text">EncoderRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BitmapEncoder"><span class="nav-text">BitmapEncoder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ResourceDecoderRegistry"><span class="nav-text">ResourceDecoderRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ByteBufferBitmapDecoder"><span class="nav-text">ByteBufferBitmapDecoder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Downsampler"><span class="nav-text">Downsampler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ResourceEncoderRegistry"><span class="nav-text">ResourceEncoderRegistry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataRewinderRegistry"><span class="nav-text">DataRewinderRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamRewinder"><span class="nav-text">InputStreamRewinder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TranscoderRegistry"><span class="nav-text">TranscoderRegistry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitmapBytesTranscoder"><span class="nav-text">BitmapBytesTranscoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujiakuo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

<script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>


  <script src="/js/schemes/muse.js?v=7.3.0"></script>



<script src="/js/next-boot.js?v=7.3.0"></script>




  




























  

  

  


  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>


</body>
</html>
